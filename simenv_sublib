#!bash

# Function : help
#
function _help
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/help/\\e[1m&\\e[0m/
                           s/subcmd/\\e[4m&\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/printf "&"/e
                          '
usage: help [--help|-h] subcmd
USAGE
  exit ${1:-0}
  }

  if ((!$#)); then
    simenv --help
    return
  fi

  opts=$(getopt -a -oh -lhelp -- "$@")
  if (($?)); then
    exit 2
  fi

  #echo "options: ($opts)"
  eval set -- $opts

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      --) shift
          ;;

      help)
        usage
        ;;

      [[:alpha:]]+([[:alnum:]_]))
        simenv $1 --help
        return
        ;;
    esac
  done
}

# Function : edit
#
function _edit
{
  local file=$(get_bin_dir)/simenv

  if [[ $1 && $1 == lib ]]; then
    file=$(get_bin_dir)/simenv_sublib
  fi

  w=$(ls -l $file | cut -d' ' -f1 | sed -r 's/-.(.).{7}/\1/')

  if [[ $w == - ]]; then
    icmp4 edit $file
  fi

  gvim $file
}

# Function : open
#
function _open
{
  local file=$(get_bin_dir)/simenv

  if [[ $1 && $1 == lib ]]; then
    file=$(get_bin_dir)/simenv_sublib
  fi

  gvim $file
}

# Function: changelist
#
function _changelist
{
  function usage
  {
    echo "usage: changelist     [--help|-h] [dirbase...]"
    echo "       changelist set dirbase:CL#..."
    echo
    echo "Options:"
    echo "  -h, --help        Print this help message"
    echo
    echo "Arguments:"
    echo "  dirbase...        Directory bases to extract the changelists from"
    echo "  dirbase:CL#...    Directory bases to set the changelists to"
    echo
    exit ${1:-0}
  }

  if [[ $1 =~ ^set$ ]]; then
    changelist_set "${@:2}"

  else

    opts=$(getopt -a -o h -l help -- "$@")
    if (($?)); then
      usage 1
    fi

    eval set -- $opts

    while (($#)); do
      case $1 in
        --help|-h)
          usage
          ;;

        --) shift
            ;;

        -*) echo "Unrecognized option: $1"
            usage
            ;;

        *)  dirbase[$((dirid++))]=$1
            shift
            ;;
      esac
    done

    if ((dirid==0)); then
      echo -e "\e[1;31m-W-\e[0m No directory base specified\n"
      echo -e "Available bases: \e[1m$(ls -d $WORKSPACE_ROOT/*/ | xargs basename -a | xargs)\e[0m"
      echo
      usage
    fi

    for d in "${dirbase[@]}"; do
       cd $WORKSPACE_ROOT/$d
       echo -e "$d\t$(icmp4 cstat ... | grep -B1 'status have' | grep change | cut -d' ' -f3 | sort -rn | head -1)"
    done
  fi
}

# Function: changelist_set
#
function changelist_set
{
  function usage
  {
    echo "usage: changelist set dirbase:CL#..."
    exit ${1:-0}
  }

  if ((!$#)); then
    echo -e "\e[1;31m-W-\e[0m No dirbase/CL# pair specified\n"
    usage 1
  fi

  declare -A pair

  for p in "$@"; do
    if [[ $p =~ ^([[:alpha:]]+):([[:digit:]]+|head|latest)$ ]]; then
      pair[${BASH_REMATCH[1]}]=${BASH_REMATCH[2]}
    else
      echo -e "\e[1;31m-E-\e[0m Invalid dirbase/CL# pair '$p'\n"
      usage 2
    fi
  done

  cd $WORKSPACE_ROOT

  for d in "${!pair[@]}"; do
    if [[ ! -d $d ]]; then
      echo -e "\e[1;31m-E-\e[0m Subdirectory '$d' does not exist\n"
      continue
    fi

    echo "$d -> ${pair[$d]}"
    pushd $d 2>&1 >/dev/null
    # echo $PWD
    if [[ ${pair[$d]} =~ ^(head|latest)$ ]]; then
      icmp4 sync ...#head
    else
      icmp4 sync ...@${pair[$d]}
    fi

    popd 2>&1 >/dev/null
  done
}

# Function: compile
#
function _compile
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/compile/\\e[1m&\\e[0m/
                           s/ (queue|logfile)/ \\e[4m\1\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: compile  --topology|-t top|rfams|adc|dac
                [--help|-h]
                [-n]
                [--debug|-d  dump|batch | verdi|gui]
                [--lsf|-l 1|2]
                [--queue|-q queue  | --local]
                [--make-debug]
                [--output-log|--ol|-o logfile]
USAGE
  exit ${1:-0}
  }

  local topology debug lsf=99 dry queue logfile local

  if [[ $1 =~ ^(top|rfams|adc|dac) ]]; then
    local topo=$1
    shift

    set -- --topology $topo "$@"
  fi

  opts=$(getopt -a -ot:,d:,l:,n,h,q:,o: -ltopology:,debug:,lsf:,help,make-debug,queue:,output-log:,ol:,local -- "$@")
  if (($?)); then
    exit 2
  fi

  #echo "options: ($opts)"
  eval set -- $opts

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      --topology|-t)
        topology=$2
        shift 2

        if ! [[ $topology =~ top|rfams|adc|dac ]]; then
          echo -e "\e[1;31m-E-\e[0m Unsupported topology '\e[31m$topology\e[0m', please use one of \e[1;34mtop\e[0m|\e[1;34mrfams\e[0m|\e[1;34madc\e[0m|\e[1;34mdac\e[0m\n"
          usage 1
        fi

        topology=$(sed 's/.*/\U&/' <<<$topology)
        ;;

      --debug|-d)
        debug=$2
        shift 2
        ;;

      --make-debug)
        make_debug=1
        shift
        ;;

      --lsf|-l)
        lsf=$2
        shift 2
        ;;

      --queue|-q)
        queue=$2
        shift 2
        ;;

      --local)
        local=1
        shift
        ;;

      --output-log|--ol|-o)
        logfile=$2
        shift 2
        ;;

      -n) dry=1
          shift
          ;;

      *)  shift
          ;;
    esac
  done

  if [[ -z $topology ]]; then
    echo -e "\e[1;31m-E-\e[0m Missing topology, please use \e[1m--topology|-t\e[0m \e[1;34mtop\e[0m|\e[1;34mrfams\e[0m|\e[1;34madc\e[0m|\e[1;34mdac\e[0m\n"
    usage 2
  fi

  if [[ $debug ]]; then
    case $debug in
      dump|batch)
        debug="DUMP_EN=1"
        ;;

      gui|verdi)
        debug="RUN_GUI=enabled"
        ;;

      *)
        echo -e "\e[1;31m-E-\e[0m Unsupported debug type '\e[31m$debug\e[0m', please use one of \e[1;34mdump\e[0m|\e[1;34mbatch\e[0m or \e[1;34mgui\e[0m|\e[1;34mverdi\e[0m\n"
        usage 3
        ;;
    esac
  fi

  #${dry:+echo} cd $PROJ_RUN

  ${dry:+echo}                                \
  $(if ((!dry)); then echo eval; fi)          \
  $(simenv lsf_cmd $lsf ${queue:+-q $queue} ${local:+--local}) \
  make   -f $PROJ_BIN/Makefile ${make_debug:+-dpw}             \
  ${debug:+$debug FSDB=1 UVM_DEBUG=1}         \
  ${topology:+TOPOLOGY=$topology}             \
  compile                                     \
  $(if ((make_debug)); then
      if [[ $logfile ]]; then
        echo "|& tee $logfile"
      else
        echo "|& tee make_debug.log"
      fi
    elif [[ $logfile ]]; then
      echo "|& tee $logfile"
    fi
   )
}


# Function: run
#
function _run
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/run/\\e[1m&\\e[0m/
                           s/testname/\\e[1;34m&\\e[0m/
                           s/ (count)/ \\e[4m\1\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: run  testname
            [--help|-h]
            [-n]
            [--debug|-d  dump|batch | verdi|gui]
            [--svseed|--seed|-s <seed>]
            [--verbosity|-v low|medium|high|full|debug]
            [--max-quit-count count]
            [--dump_fe_ti_data|--ti_data]
            [--log]
            [--lsf|-l 1|2]
            [--queue|-q <queue>  | --local]
            [--make-debug]
USAGE
  exit ${1:-0}
  }

  local debug verbosity=low svseed lsf=99 dry local quit_count plusargs log

  opts=$(getopt -a -od:,v:,s:,l:,h,n,q: -ldebug:,verbosity:,svseed:,seed:,lsf:,help,make-debug,queue:,local,max-quit-count:,dump_fe_ti_data,ti_data,log -- "$@")
  if (($?)); then
    exit 2
  fi

  #echo "options: ($opts)"
  eval set -- $opts

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      --debug|-d)
        debug=$2
        shift 2
        ;;

      --make-debug)
        make_debug=1
        shift
        ;;

      --verbosity|-v)
        verbosity=$2
        shift 2

        if ! [[ $verbosity =~ low|medium|high|full|debug ]]; then
          echo -e "\e[1;31m-E-\e[0m Unknown verbosity '\e[31m$verbosity\e[0m', please use one of \e[1;34mlow\e[0m|\e[1;34mmedium\e[0m|\e[1;34mhigh\e[0m|\e[1;34mfull\e[0m|\e[1;34mdebug\e[0m\n"
          usage 1
        fi
        ;;

      --max-quit-count)
        quit_count=$2
        shift 2
        ;;

      --dump_fe_ti_data|--ti_data)
        if [[ -z $plusargs ]]; then
          plusargs="+dump_fe_ti_data"
        else
          plusargs+=" +dump_fe_ti_data"
        fi

        shift
        ;;

      --log)
        log=1
        shift
        ;;

      --svseed|--seed|-s)
        svseed=$2
        shift 2
        ;;

      --lsf|-l)
        lsf=$2
        shift 2
        ;;

      --queue|-q)
        queue=$2
        shift 2
        ;;

      --local)
        local=1
        shift
        ;;

      -n) dry=1
          shift
          ;;

      --) shift
          ;;

      +([[:word:]]))
          testname=$1
          shift
          ;;
    esac
  done

  if [[ -z $testname ]]; then
    echo -e "\e[1;31m-E-\e[0m Missing UVM test, please provide one positional argument/\n"
    usage 2
  fi

  if [[ $debug ]]; then
    case $debug in
      dump|batch)
        debug="DUMP_EN=1"
        ;;

      gui|verdi)
        debug="RUN_GUI=enabled UVM_DEBUG=1"
        ;;
      *)
        echo -e "\e[1;31m-E-\e[0m Unsupported debug type '\e[31m$debug\e[0m', please use one of \e[1;34mdump\e[0m|\e[1;34mbatch\e[0m or \e[1;34mgui\e[0m|\e[1;34mverdi\e[0m\n"
        usage 3
        ;;
    esac
  fi

  verbosity=$(sed 's/.*/UVM_\U&/' <<<$verbosity)

  function run
  {
    #${dry:+echo} cd $PROJ_RUN

    if ((!dry)); then
      echo Run started at $(date)
    fi

    ${dry:+echo}                                \
    $(if ((!dry)); then echo eval; fi)          \
    $(simenv lsf_cmd $lsf ${queue:+-q $queue} ${local:+--local} ) \
    make   -f $PROJ_BIN/Makefile ${make_debug:+-dpw}              \
    $debug                                        \
    ${quit_count:+UVM_MAX_QUIT_COUNT=$quit_count} \
    ${verbosity:+UVM_VERBOSITY=$verbosity}        \
    ${plusargs:+USER_PLUSARGS="\"$plusargs\""}    \
    run                                           \
    ${svseed:+SVSEED=$svseed}                     \
    UVM_TESTNAME=$testname

    if ((!dry)); then
      echo Run ended at $(date)
    fi
  }


  eval run ${log:+ "|&" tee $testname.run.log}
}

# Function: runtest
#
function _runtest
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/runtest/\\e[1m&\\e[0m/
                           s/testname/\\e[1;34m&\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: runtest  testname
                --topology|-t top|adc|dac
                [--help|-h]
                [-n]
                [--debug|-d  dump|batch | verdi|gui]
                [--verbosity|-v low|medium|high|full|debug]
                [--svseed|--seed|-s <seed>]
                [--lsf|-l 1|2]
                [--queue|-q <queue>]

       runtest  top|adc|dac testname
                [--help|-h]
                [-n]
                [--debug|-d  dump|batch | verdi|gui]
                [--verbosity|-v low|medium|high|full|debug]
                [--svseed|--seed|-s <seed>]
                [--lsf|-l 1|2]
                [--queue|-q <queue>]
USAGE
  exit ${1:-0}
  }

  local topology debug verbosity=low svseed lsf=99 dry make_debug queue

  if [[ $1 =~ ^(top|adc|dac) ]]; then
    local topo=$1
    shift

    set -- --topology $topo "$@"
  fi

  opts=$(getopt -a -ot:,d:,v:,s:,l:,h,n,q:  -ltopology:,debug:,verbosity:,svseed:,seed:,lsf:,help,make-debug,queue: -- "$@")
  if (($?)); then
    exit 2
  fi

  #echo "options: ($opts)"
  eval set -- $opts

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      -n) dry=1
          shift
          ;;

      --topology|-t)
        topology=$2
        shift 2
        ;;

      --debug|-d)
        debug=$2
        shift 2
        ;;

      --make-debug)
        make_debug=1
        shift
        ;;

      --verbosity|-v)
        verbosity=$2
        shift 2
        ;;

      --svseed|--seed|-s)
        svseed=$2
        shift 2
        ;;

      --lsf|-l)
        lsf=$2
        shift 2
        ;;

      --queue|-q)
        queue=$2
        shift 2
        ;;

      --) shift
          ;;

      +([[:word:]]))
          testname=$1
          shift
          ;;
    esac
  done

  if [[ -z $testname ]]; then
    echo -e "\e[1;31m-E-\e[0m Missing UVM test, please provide one positional argument.\n"
    usage 1
  fi

  simenv  compile                   \
  ${dry:+-n}                        \
  ${topology:+--topology $topology} \
  ${debug:+--debug $debug}          \
  ${make_debug:+--make-debug}       \
  ${lsf:+--lsf $lsf}                \
  ${queue:+-q $queue}

  if (($?)); then
    exit 2
  fi

  ${dry:+echo}

  simenv  run                           \
  $testname                             \
  ${dry:+-n}                            \
  ${debug:+--debug $debug}              \
  ${make_debug:+--make-debug}           \
  ${verbosity:+--verbosity $verbosity}  \
  ${svseed:+--svseed $svseed}           \
  ${lsf:+--lsf $lsf}                    \
  ${queue:+-q $queue}

}

# Function: regr
#
function _regr
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/regr/\\e[1m&\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: regr [--topology|-t] adc|dac
            [--help|-h]
            [-n]
USAGE
  exit ${1:-0}
  }

  local dry lsf=99 local

  if ((!$#)); then
    usage
  fi

  if [[ $1 =~ ^(adc|dac) ]]; then
    local topo=$1
    shift

    set -- --topology $topo "$@"
  fi

  opts=$(getopt -a -oh,n,t: -lhelp,local,topology: -- "$@")
  if (($?)); then
    exit 2
  fi

  #echo "options: ($opts)"
  eval set -- $opts

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      -n) dry=1
          shift
          ;;

      --topology|-t)
        topology=$2
        shift 2
        ;;

      --) shift
          ;;

      *) echo -e "\e[1;31m-E-\e[0m Extra argument '\e[31m$1\e[0m' not supported"
         usage 1
         ;;
    esac
  done


  ${dry:+echo} cd $PROJ_RUN

  ${dry:+echo}                        \
  $(if ((!dry)); then echo eval; fi)  \
  make  run_rgr                       \
  RGR_SD=                             \
  EMAIL=$USER                         \
  TOPOLOGY=${topology^^} "&"
}


# Function: grep
#
#   When executed from t(csh) please set the 'nonomatch' variable
#
#   $ set nonomatch
#
function _grep
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/grep/\\e[1m&\\e[0m/g
                           s/regex|space.+list/\\e[4m&\\e[0m/g
                           s/(ext|file|dir)glob|directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: grep regex..
            [--help|-h]
            [-I] [-s] [-i] [-n] [--dry-run]
            [-x.extglob{,extglob}]...
            [-xfileglob{,fileglob}]...
            [--xd|-D|-X dirglob{,dirglob}]..
            [-d directory | --cwd | --uvm|-u | --project|-p]
            [--lsf|-l 1|2]
            [--queue|-q queue]

       grep add <space separated option list>
       grep edit
       grep list
USAGE
  exit ${1:-0}
  }

  function add_glob
  {
    local t=$1 spec=$2

    for it in $(sed -r 's/^|$/"/g; s/,/" "/g' <<<$spec); do
      eval ${t}glob[$((${t}id++))]=$it
      #eval echo "\"${t^^}: #\$${t}id = $it\""
    done
  }

  local extglob extid fileglob fileid dirglob dirid regex reid
  local nobinary nomessage ignorecase linenumber lsf queue directory
  local dry_run uvm project

  if ((!$#)); then
    usage 1
  fi

  local regex
  case $1 in
    @(class|module|interface|function|task|routine))
      # $2 ≡ name of the entity to look for

      case $1 in
        class)
          regex="^\s*(virtual\s+)?$1\s+$2\>"
          ;;

        module|interface)
          regex="^\s*$1\s+(.+)?\<$2\>"
          ;;

        function|task)
          regex="^\s*([[:alnum:]_]+\s+){,2}$1\s+(.+)?\<$2\>"
          ;;

        routine)
          regex="^\s*([[:alnum:]_]+\s+){,2}(function|task)\s+(.+)?\<$2\>"
          ;;

      esac

      shift 2

      set -- "$regex" "$@"
      ;;

    option)
      case $2 in
        add)
          shift 2

          echo "$@" >> $(get_local)/option.list
          nl $(get_local)/option.list
          ;;

        remove)
          rm -v $(get_local)/option.list
          ;;

        list)
          nl $(get_local)/option.list
          ;;

        edit)
          gvim $(get_local)/option.list
          ;;
      esac

      return
      ;;
  esac


  if [[ -s $(get_local)/option.list ]]; then
    set -- $(tail -1 $(get_local)/option.list)  "$@"
  fi

  opt=$(getopt -a -oh,I,s,i,x:,l:,q:,d:,u,n,p,D:,X:  -lhelp,xd:,lsf:,queue:,cwd,uvm,dry-run,project -- "$@")
  if (($?)); then
    usage 2
  fi

  #echo "option: ($opt)"

  eval set -- $opt

  while (($#)); do
    #echo $# \"$1\"
    case $1 in
      --help|-h)
        usage
        ;;

      -I) nobinary=1
          shift
          ;;

      -s) nomessage=1
          shift
          ;;

      -i) ignorecase=1
          shift
          ;;

      -n) linenumber=1
          shift
          ;;

      --dry-run)
          dry_run=1
          shift
          ;;

      -x)
        if [[ $2 =~ ^\. ]]; then # file extension globs
          add_glob ext "${2:1}"
        else # file name globs
          add_glob file "$2"
        fi

        shift 2
        ;;

      --xd|-D|-X) # directory globs
        add_glob dir "$2"
        shift 2
        ;;

      -d) directory=$2
          shift 2

          if ! [[ -d $directory ]]; then
            echo -e "-E- Non-existent directory '\e[1m$directory\e[0m'"
            exit 3
          fi

          # absolute path
          directory=$(readlink -e $directory)
          ;;

      --cwd)
        directory=$PWD
        shift
        ;;

      --uvm|-u)
        uvm=1
        shift
        ;;

      --project|-p)
        project=1
        shift
        ;;

      --lsf|-l)
        lsf=$2
        shift 2
        ;;

      --queue|-q)
        queue=$2
        shift 2
        ;;

      --) shift
          ;;

      *)
        regex[$((reid++))]="\"$1\""
        shift
        ;;

    esac
  done

  if (( ${#regex[@]} == 0 )); then
    echo -e "\e[1;31m-E-\e[0m No regex specified"
    usage 3
  fi

  $(if ((dry_run)); then echo echo; else echo eval; fi)               \
  grep  --color -Er                                                   \
  ${nobinary:+-I}                                                     \
  ${nomessage:+-s}                                                    \
  ${ignorecase:+-i}                                                   \
  ${linenumber:+-n}                                                   \
  $(for r in "${regex[@]}";    do  echo "-e $r"; done)                \
  $(for e in "${extglob[@]}";  do  echo --exclude "\"*.$e\""; done)   \
  $(for f in "${fileglob[@]}"; do  echo --exclude "\"$f\""; done)     \
  $(for d in "${dirglob[@]}";  do  echo --exclude-dir "\"$d\""; done) \
  $(if [[ $directory ]]; then
      echo $directory
    elif ((uvm)); then
      echo $UVM_HOME
    elif ((project)); then
      echo $PROJ_DIR
    else
      echo $WORKSPACE_ROOT
    fi
   )

}

# Function: class
#
function _class
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/class/\\e[1m&\\e[0m/g
                           s/name|grep-options|servername/\\e[4m&\\e[0m/g
                           s/(ext|file|dir)glob|directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: class  name...
              [--help|-h]
              [--vim[-all] [servername]]
              [grep-options]
USAGE

  exit ${1:-0}
  }


  if ((!$#)); then
    usage
  fi

  local name id vim

  while (($#)) && ! [[ $1 =~ ^- ]]; do
    name[$((id++))]="$1"

    shift
  done

  if ((!id)); then
    if [[ $1 =~ ^--?h(e(lp?)?)?$ ]]; then
      usage
    else
      echo -e "\e[1;31m-E-\e[0m At least one name regex is needed\n"
      usage 1
    fi
  fi

  local regex
  if ((id > 1)); then
    regex=$(sed 's/^/(/; s/$/)/; s/ /|/g' <<<"${name[@]}")
  else
    regex=$name
  fi

  local vimall
  if (($#)); then
    if [[ $1 =~ ^--?vim(-all)?$ ]]; then
      shift

      vimall=${BASH_REMATCH[1]:+1}
      if (($#)) && [[ $1 =~ ^[[:alnum:]_]+$ ]]; then
        vim=$1

        shift
      else
        vim=GVIM$RANDOM
      fi
    fi
  fi

  local capture lc

  if [[ $vim ]]; then
    capture=$(simenv grep class "$regex" "$@")

    if [[ $capture ]]; then
      lc=$(echo "$capture" | sort -u | wc -l)

      if ((lc == 1 || vimall)); then
        gvim --servername $vim --remote-tab-silent $(echo "$capture" | sort -u | cut -d: -f1)
      else
        echo "$capture" | grep --color -E "$regex"
      fi
    fi
  else
    simenv grep class "$regex" "$@"
  fi
}

# Function: module
#
function _module
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/module/\\e[1m&\\e[0m/g
                           s/name|grep-options|servername/\\e[4m&\\e[0m/g
                           s/(ext|file|dir)glob|directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: module  name...
               [--help|-h]
               [--vim[-all] [servername]]
               [grep-options]
USAGE

  exit ${1:-0}
  }


  if ((!$#)); then
    usage
  fi

  local name id vim

  while (($#)) && ! [[ $1 =~ ^- ]]; do
    name[$((id++))]="$1"

    shift
  done

  if ((!id)); then
    if [[ $1 =~ ^--?h(e(lp?)?)?$ ]]; then
      usage
    else
      echo -e "\e[1;31m-E-\e[0m At least one name regex is needed\n"
      usage 1
    fi
  fi

  local regex
  if ((id > 1)); then
    regex=$(sed 's/^/(/; s/$/)/; s/ /|/g' <<<"${name[@]}")
  else
    regex=$name
  fi

  local vimall
  if (($#)); then
    if [[ $1 =~ ^--?vim(-all)?$ ]]; then
      shift

      vimall=${BASH_REMATCH[1]:+1}
      if (($#)) && [[ $1 =~ ^[[:alnum:]_]+$ ]]; then
        vim=$1

        shift
      else
        vim=GVIM$RANDOM
      fi
    fi
  fi

  local capture lc

  if [[ $vim ]]; then
    capture=$(simenv grep module "$regex" "$@")

    if [[ $capture ]]; then
      lc=$(echo "$capture" | sort -u | wc -l)

      if ((lc == 1 || vimall)); then
        gvim --servername $vim --remote-tab-silent $(echo "$capture" | sort -u | cut -d: -f1)
      else
        echo "$capture" | grep --color -E "$regex"
      fi
    fi
  else
    simenv grep module "$regex" "$@"
  fi
}

# Function: interface
#
function _interface
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/interface/\\e[1m&\\e[0m/g
                           s/name|grep-options|servername/\\e[4m&\\e[0m/g
                           s/(ext|file|dir)glob|directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: interface  name...
                  [--help|-h]
                  [--vim[-all] [servername]]
                  [grep-options]
USAGE

  exit ${1:-0}
  }


  if ((!$#)); then
    usage
  fi

  local name id vim

  while (($#)) && ! [[ $1 =~ ^- ]]; do
    name[$((id++))]="$1"

    shift
  done

  if ((!id)); then
    if [[ $1 =~ ^--?h(e(lp?)?)?$ ]]; then
      usage
    else
      echo -e "\e[1;31m-E-\e[0m At least one name regex is needed\n"
      usage 1
    fi
  fi

  local regex
  if ((id > 1)); then
    regex=$(sed 's/^/(/; s/$/)/; s/ /|/g' <<<"${name[@]}")
  else
    regex=$name
  fi

  local vimall
  if (($#)); then
    if [[ $1 =~ ^--?vim(-all)?$ ]]; then
      shift

      vimall=${BASH_REMATCH[1]:+1}
      if (($#)) && [[ $1 =~ ^[[:alnum:]_]+$ ]]; then
        vim=$1

        shift
      else
        vim=GVIM$RANDOM
      fi
    fi
  fi

  local capture lc

  if [[ $vim ]]; then
    capture=$(simenv grep interface "$regex" "$@")

    if [[ $capture ]]; then
      lc=$(echo "$capture" | sort -u| wc -l)

      if ((lc == 1 || vimall)); then
        gvim --servername $vim --remote-tab-silent $(echo "$capture" | sort -u | cut -d: -f1)
      else
        echo "$capture" | grep --color -E "$regex"
      fi
    fi
  else
    simenv grep interface "$regex" "$@"
  fi
}

# Function: function
#
function _function
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/function/\\e[1m&\\e[0m/g
                           s/name|grep-options/\\e[4m&\\e[0m/g
                           s/(ext|file|dir)glob|directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: function name...
                [--help|-h]
                [grep-options]
USAGE

  exit ${1:-0}
  }


  if ((!$#)); then
    usage
  fi

  local name id

  while (($#)) && ! [[ $1 =~ ^- ]]; do
    name[$((id++))]="$1"

    shift
  done

  if ((!id)); then
    if [[ $1 =~ ^--?h(e(lp?)?)?$ ]]; then
      usage
    else
      echo -e "\e[1;31m-E-\e[0m At least one name regex is needed\n"
      usage 1
    fi
  fi

  local regex
  if ((id > 1)); then
    regex=$(sed 's/^/(/; s/$/)/; s/ /|/g' <<<"${name[@]}")
  else
    regex=$name
  fi

  simenv grep function "$regex" "$@"
}

# Function: task
#
function _task
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/task/\\e[1m&\\e[0m/g
                           s/name|grep-options/\\e[4m&\\e[0m/g
                           s/(ext|file|dir)glob|directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: task name...
            [--help|-h]
            [grep-options]
USAGE

  exit ${1:-0}
  }


  if ((!$#)); then
    usage
  fi

  local name id

  while (($#)) && ! [[ $1 =~ ^- ]]; do
    name[$((id++))]="$1"

    shift
  done

  if ((!id)); then
    if [[ $1 =~ ^--?h(e(lp?)?)?$ ]]; then
      usage
    else
      echo -e "\e[1;31m-E-\e[0m At least one name regex is needed\n"
      usage 1
    fi
  fi

  local regex
  if ((id > 1)); then
    regex=$(sed 's/^/(/; s/$/)/; s/ /|/g' <<<"${name[@]}")
  else
    regex=$name
  fi

  simenv grep task "$regex" "$@"
}

# Function: routine
#
function _routine
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/routine/\\e[1m&\\e[0m/g
                           s/name|grep-options/\\e[4m&\\e[0m/g
                           s/(ext|file|dir)glob|directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: routine  name...
                [--help|-h]
                [grep-options]
USAGE

  exit ${1:-0}
  }


  if ((!$#)); then
    usage
  fi

  local name id

  while (($#)) && ! [[ $1 =~ ^- ]]; do
    name[$((id++))]="$1"

    shift
  done

  if ((!id)); then
    if [[ $1 =~ ^--?h(e(lp?)?)?$ ]]; then
      usage
    else
      echo -e "\e[1;31m-E-\e[0m At least one name regex is needed\n"
      usage 1
    fi
  fi

  local regex
  if ((id > 1)); then
    regex=$(sed 's/^/(/; s/$/)/; s/ /|/g' <<<"${name[@]}")
  else
    regex=$name
  fi

  simenv grep routine "$regex" "$@"
}

# Function: type_id_create
#
function _type_id_create
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/class/\\e[1m&\\e[0m/g
                           s/name|grep-options/\\e[4m&\\e[0m/g
                           s/(ext|file|dir)glob|directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: type_id_create   name...
                        [--help|-h]
                        [grep-options]
USAGE

  exit ${1:-0}
  }


  if ((!$#)); then
    usage
  fi

  local name id

  while (($#)) && ! [[ $1 =~ ^- ]]; do
    name[$((id++))]="$1"

    shift
  done

  if ((!id)); then
    if [[ $1 =~ ^--?h(e(lp?)?)?$ ]]; then
      usage
    else
      echo -e "\e[1;31m-E-\e[0m At least one name regex is needed\n"
      usage 1
    fi
  fi

  local regex
  if ((id > 1)); then
    regex=$(sed 's/^/(/; s/$/)/; s/ /|/g' <<<"${name[@]}")
  else
    regex=$name
  fi

  simenv grep "\<$regex.*::type_id::create" "$@"
}


# Function: find
#
function _find
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/find/\\e[1m&\\e[0m/g
                           s/glob/\\e[4m&\\e[0m/g
                           s/directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: find glob...
            [--help|-h]
            [--type|-t f|d]
            [-d directory{[,| ]directory} | --cwd | --uvm|-u | --project|-p]
            [--lsf|-l 1|2]
            [--queue|-q queue]
USAGE
  exit ${1:-0}
  }

  local glob gid ftype uvm project directory lsf queue

  if ((!$#)); then
    usage 1
  fi

  if [[ $1 =~ ^(file|dir)$ ]]; then
    local t=$1
    shift

    set -- --type ${t:0:1} "$@"
    unset t
  fi


  opt=$(getopt -a -oh,q:,d:,u,t:,p  -lhelp,lsf:,queue:,cwd,uvm,type:,project -- "$@")
  if (($?)); then
    usage 2
  fi

  #echo "options: ($opt)"

  eval set -- $opt

  while (($#)); do
    #echo "$#: <$1>"
    case $1 in
      --help|-h)
        usage
        ;;

      --type|-t)
        ftype=$2
        shift 2
        diron=0

        if ! [[ $ftype =~ ^(f|d)$ ]]; then
          echo -e "\e[1;31m-E-\e[0m Unsupported type '$ftype', please use one of \e[1;34mf\e[0m|\e[1;34md\e[0m"
          exit 4
        fi
        ;;

      -d) _d=$2
          shift 2

          diron=1
          if [[ $_d =~ ,$ ]]; then
            _d=$(echo $_d | sed 's/,$//')
          fi

          _d=$(echo $_d | sed 's/,/ /g')

          ned=0
          for d in $_d; do
            if ! [[ -d $d ]]; then
              echo -e "\e[1;31m-E-\e[0m Non-existent directory '\e[1m$d\e[0m'"
              ((ned++))
            fi
          done
          if ((ned)); then exit 3; fi

          # Absolute Path
          for d in $_d; do
            directory[$((dirid++))]=$(readlink -e $d)
          done
          ;;

      --cwd)
        directory=($PWD)
        shift
        diron=0
        ;;

      --uvm|-u)
        uvm=1
        shift
        diron=0
        ;;

      --project|-p)
        project=1
        shift
        diron=0
        ;;

      --lsf|-l)
        lsf=$2
        shift 2
        diron=0
        ;;      

      --queue|-q)
        queue=$2
        shift 2
        diron=0
        ;;      

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unsupported option '\e[1m$1\e0m'"
          exit 6
          ;;

      ,)  shift;
          ;;

      *) #echo "diron<$diron>"
        if ((diron)); then
              #echo "(1) \$1<$1>"
          _d=$(echo $1 | sed 's/,/ /g')
              #echo "(2) _d<$_d>"

          for d in $_d; do
            if ((diron)); then
              if [[ -d $d ]]; then
                directory[$((dirid++))]=$(readlink -e $d)
              else
                #echo -e "\e[1;31m-E-\e[0m Non-existent directory '\e[1m$d\e[0m'"
                glob[$((gid++))]=\"$d\" 
                diron=0
              fi
            else
              glob[$((gid++))]=\"$d\" 
            fi
          done

        else
          glob[$((gid++))]=\"$1\" 
        fi

        shift
        ;;

    esac
    #echo "BOTTOM: diron<$diron>"
  done


  eval find                               \
            $(if (( ${#directory} )); then
                  echo ${directory[@]}
                elif ((uvm)); then
                  echo $UVM_HOME
                elif ((project)); then
                  echo $PROJ_DIR
                else
                  echo $WORKSPACE_ROOT
                fi
               )                          \
              ${ftype:+-type $ftype}      \
              $(if ((${#glob[@]})); then echo '\('; fi

                for ((k=0; k < ${#glob[@]}; k++)); do
                  echo $(if ((k)); then echo -o; fi) -name ${glob[$k]}
                done

                if ((${#glob[@]})); then echo '\)'; fi
                )

}

# Function: file
#
#   file ≡ find file
#
function _file
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/file/\\e[1m&\\e[0m/g
                           s/glob/\\e[4m&\\e[0m/g
                           s/find-options/\\e[4m&\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: file [find-options] glob...
USAGE
  exit ${1:-0}
  }

  if ((!$#)); then
    usage 1
  fi

  simenv find file "$@"
}

# Function: dir
#
#   dir ≡ find dir
#
function _dir
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/dir/\\e[1m&\\e[0m/g
                           s/glob/\\e[4m&\\e[0m/g
                           s/find-options/\\e[4m&\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: dir [find-options] glob...
USAGE
  exit ${1:-0}
  }

  if ((!$#)); then
    usage 1
  fi

  simenv find dir "$@"
}

# Function: ext
#
#   ext extglob... ≡ find file *.extglob..
#
function _ext
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/ext/\\e[1m&\\e[0m/g
                           s/glob/\\e[4m&\\e[0m/g
                           s/directory/\\e[4m&\\e[0m/g
                           s/ (queue)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: ext  glob...
            [--help|-h]
            [-d directory | --cwd | --uvm|-u  | --project|-p]
            [--lsf|-l 1|2]
            [--queue|-q queue]
USAGE
  exit ${1:-0}
  }

  local glob gid directory uvm lsf queue

  if ((!$#)); then
    usage 1
  fi

  opt=$(getopt -a -oh,q:,d:,u,p  -lhelp,lsf:,queue:,cwd,uvm,project -- "$@")
  if (($?)); then
    usage 1
  fi

  #echo "options: ($opt)"

  eval set -- $opt

  while (($#)); do
    #echo $# \"$1\"
    case $1 in
      --help|-h)
        usage
        ;;

      -d) directory=$2
          shift 2

          if ! [[ -d $directory ]]; then
            echo -e "\e[1;31m-E-\e[0m Non-existent directory '\e[1m$directory\e[0m'"
            exit 3
          fi

          # absolute path
          directory=$(readlink -e $directory)
          ;;

      --cwd)
        directory=$PWD
        shift
        ;;

      --uvm|-u)
        uvm=1
        shift
        ;;

      --project|-p)
        directory=$PROJ_DIR
        shift
        ;;

      --lsf|-l)
        lsf=$2
        shift 2
        ;;

      --queue|-q)
        queue=$2
        shift 2
        ;;

      --) shift
          ;;

      *)
        glob[$((gid++))]=\"$1\"
        shift
        ;;

    esac
  done

  eval  simenv find file              \
        ${directory:+-d $directory}   \
        ${uvm:+--uvm}                 \
        ${lsf:+--lst $lsf}            \
        ${queue:+--queue $queue}      \
        $(for e in ${glob[@]}; do echo \"*.$e\"; done)
}


# Function: lsf_cmd
#
function _lsf_cmd
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/lsf_cmd/\\e[1m&\\e[0m/
                           s/ (queue)/ \\e[4m\1\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/echo -e "&"/e
                          '
usage: lsf_cmd  [1|2|..]
                [--help|-h]
                [--queue|-q queue  | --local]
USAGE
  exit ${1:-0}
  }

  local opt=99 lsf_spec queue local project=$(basename $WORKSPACE_ROOT)

  while (($#)); do
    case $1 in
      -?(-)help|-h)
        usage
        ;;

      --queue|-q)
        queue=$2
        shift 2
        ;;

      -?(-)local)
        local=1
        shift
        ;;

      -*) echo -e "-E- Unsupported option '\e[31m$1\e[0m'\n"
          usage 1
          ;;

    +([[:digit:]]))
        opt=$1
        shift
        ;;
    esac
  done

  case $opt in
    1)  lsf_spec='"select[type==X86_64 && (osver=ws7)]"'
        ;;

    2)  lsf_spec='"select[ostype==centosws74]"'
        ;;

    # Default
    *)  case $project in
          s70*|clifden*|ws*)
            lsf_spec='"select[type==X86_64 && ostype==rhelws79]"'
            ;;

          sdfec)
            lsf_spec='"select[type==X86_64 && (osver=sv7 || osver=ws7)] rusage[mem=15000]"'
        esac
        ;;
  esac

  if ((!local)); then
    echo bsub ${queue:+-q $queue} -I -R $lsf_spec
  fi
}


# Function: reg_model
#
function _reg_model
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/reg_model/\\e[1m&\\e[0m/
                           s/ (mode|directory)/ \\e[4m\1\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/printf "&"/e
                          '
usage: reg_model  model
                  [--slice]
                  [--directory|-d directory]
                  [--help|-h]
USAGE
  exit ${1:-0}
  }

  cd $SUB_DIR
  rm -f *

  local opt model slice odir

  opt=$(getopt -a -oh,d:  -lhelp,slice,directory: -- "$@")
  if (($?)); then
    usage 1
  fi
  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      --directory|-d)
        odir=$2
        shift 2

        if ! [[ -d $odir ]]; then
          echo -e "\e[1;31m-E-\e[0m Non-existent directory '\e[1m$odir\e[0m'"
          exit 2
        fi

        odir=$(readlink -e $odir)
        ;;

      --slice)
        slice=1
        shift
        ;;

      --)
        shift
        ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unsupported option '\e[31m$1\e[0m'\n"
          usage 1
          ;;

      *)  model=$1

          if ! [[ -f $model ]]; then
            echo -e "\e[1;31m-E-\e[0m File '$model' doesn't exist\n"
            exit 2
          elif ! [[ -s $model ]]; then
            echo -e "\e[1;31m-E-\e[0m File '$model' is empty\n"
            exit 3
          fi

          shift
          ;;
    esac
  done

  if [[ -z $model ]]; then
    echo -e "\e[1;31m-E-\e[0m Path to the register model is required\n"
    usage 1
  fi

  [[ $model =~ ([^/]+)\.([[:alpha:]]+)$ ]]
  local base=${BASH_REMATCH[1]} ext=${BASH_REMATCH[2]}

  echo "Processing $model.."

  truncate -s 0  $odir/$base.ext.$ext

  sed -r '
    /^\s*import\s+uvm_pkg::.+;/a import uvm_reg_ext_pkg::*;

    /^\s*class\s+([[:alnum:]_]+)\s+extends\s+uvm_reg\s*;/ {
      s/uvm_reg;/uvm_reg_base;/
      h
      s/^\s*class\s+([[:lower:][:digit:]_]+([[:upper:]][[:upper:][:digit:]_]+))\s.+/echo \1 > cregtype; echo \2 > cregname; echo "\1 \2;" >> reg_decl/e
      g
      :next
      n
      /^\s*endclass\s*:/  {p; d}
      s/^(\s*(rand\s+)?)uvm_reg_field(\s+([[:alnum:]_]+)\s*;)/echo "$(<cregname)_\4  $(<cregtype)" >> reg_field_type_map; echo "\1uvm_reg_field_base #($(<cregtype))\3"/e
      s/(.+=\s*)uvm_reg_field(::type_id::create\(")(.+)(".+;)/echo "\1uvm_reg_field_base #($(<cregtype))\2\\\"\3\\\"\4"/e
      b next
    }

    /^\s*class\s+([[:alnum:]_]+)\s+extends\s+uvm_reg_block\s*;/ {
      : next_2
      n
      /^s*endclass\s*:/ {p; d}
      s/^(\s*(rand\s+)?)uvm_reg_field(\s+([[:alnum:]_]+)\s*;)/echo "\1uvm_reg_field_base #($(grep "\\<\4\\>" reg_field_type_map | grep -o "\\S\\+\$"))\3"/e
      b next_2
    }

  ' $model > $odir/$base.ext.$ext

  if [[ -s $odir/$base.ext.$ext ]]; then
    echo -e "  Created $odir/$base.ext.$ext"
  else
    echo -e "\e[1;31m-E-\e[0m Couldn't create  $odir/$base.ext.$ext"
    exit 4
  fi

  cp reg_decl $odir/$base.decl.0.svh
  echo -e "  Created $odir/$base.decl.0.svh"

  sed ' s/;/[$];/' $odir/$base.decl.0.svh > $odir/$base.decl.1.svh
  echo -e "  Created $odir/$base.decl.1.svh"

  sed ' s/;/[$][$];/' $odir/$base.decl.0.svh > $odir/$base.decl.2.svh
  echo -e "  Created $odir/$base.decl.2.svh"

  if ((slice)); then
    sed ' s/;/[$][$][$];/' $odir/$base.decl.0.svh > $odir/$base.decl.3.svh
    echo -e "  Created $odir/$base.decl.3.svh"
  fi

}


# Function : copyright
#
function _copyright
{
  sed -rn '
    /^\s*copyright\>/ {
      s%^.+"%%g

      :next
      p
      n
      \%^//% ! {p; q}
      #s/\$/\\$/g
      #s/"/\\"/g
      s/\{year\}/$year/
      b next
    }

    ' $PROJ_DIR/scripts/create_init_tb_templates/copyright.py | sed -r 's/(.+) \$year (.+)/echo "\1 $(date +%Y) \2"/e'
}

# Function: add_blank
#
function _add_blank
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/add_blank/\\e[1m&\\e[0m/g
                           s/name/\\e[4m&\\e[0m/g
                           s/ (directory)/ \\e[4m\1\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/printf "&"/e
                          '
usage: add_blank  name...
                  --type|-t sv|svh
                  [--directory|-d directory | --cwd]
                  [--help|-h]
USAGE

  exit ${1:-0}
  }

  local name nid type

  if ((!$#)); then
    usage 1
  fi

  if [[ $1 =~ ^(sv|svh)$ ]]; then
    set -- --type $1 "${@:2}"
  fi

  opt=$(getopt -a -oh,d:,t:  -lhelp,type:,cwd -- "$@")
  if (($?)); then
    usage 1
  fi

  #echo "options: ($opt)"

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      --directory|-d) directory=$2
          shift 2

          if ! [[ -d $directory ]]; then
            echo -e "\e[1;31m-E-\e[0m Non-existent directory '\e[1m$directory\e[0m'"
            exit 2
          fi

          directory=$(readlink -e $directory)
          ;;

      --cwd)
        directory=$PWD
        shift
        ;;

      --type|-t)
          type=$2
          shift 2

          if ! [[ $type =~ ^(sv|svh)$ ]]; then
            echo -e "\e[1;31m-E-\e[0m There are only two types: \e[1msv\e[0m|\e[1msvh\e[0m\n"
            usage 3
          fi
          ;;

      --) shift
          ;;

      *)
        name[$((nid++))]=$1
        shift
        ;;

    esac
  done

  if [[ -z $type ]]; then
    echo -e "\e[1;31m-E-\e[0m Missing output file's type\n"
    usage 3
  fi

  set -- "${name[@]}"


  for n; do
    (
    simenv copyright

    if [[ $type == svh ]]; then
    cat <<FILE
\`ifndef  ${n^^}__SVH
\`define  ${n^^}__SVH


\`endif   // ${n^^}__SVH
FILE
    fi

    ) > $(if [[ $directory ]]; then echo $directory/$n.$type; else echo /dev/stdout; fi)

  done
}

# Function: add_package
#
function _add_package
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/(add_package) /\\e[1m\1\\e[0m /g
                           s/name|base|\<package/\\e[4m&\\e[0m/g
                           s/ (directory)/ \\e[4m\1\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/printf "&"/e
                          '
usage: add_package  name ...
                    [--import  package] ...
                    [--include base] ...
                    [--directory|-d directory | --cwd]
                    [--help|-h]

Options:

  --help|-h	      Show this help message and exit.
  --import  package   Package to import.
		      Multiple packages can be imported by repeating the option.

  --include base      File to include. Only the basename of the file needs to be specified.
		      Multiple files can be included by repeating the option.

  --directory|-d directory, --cwd
		      Destination directory.

Arguments:

  name ...	      List of packages to create.
USAGE

  exit ${1:-0}
  }

  local name nid type import imid include inid

  if ((!$#)); then
    usage 1
  fi

  opt=$(getopt -a -oh,d:,t:  -lhelp,directory:,cwd,import:,include: -- "$@")
  if (($?)); then
    usage 1
  fi

  #echo "options: ($opt)"

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      --directory|-d) directory=$2
          shift 2

          if ! [[ -d $directory ]]; then
            echo -e "\e[1;31m-E-\e[0m Non-existent directory '\e[1m$directory\e[0m'"
            exit 2
          fi

          directory=$(readlink -e $directory)
          ;;

      --cwd)
        directory=$PWD
        shift
        ;;

      --import) import[$((imid++))]=$2
          shift 2
          ;;

      --include) include[$((inid++))]=$2
          shift 2
          ;;

      --) shift
          ;;

      *)
        name[$((nid++))]=$1
        shift
        ;;

    esac
  done

  set -- "${name[@]}"


  for n; do
    (
    simenv copyright

    cat <<BEGIN
package $n;

import uvm_pkg::*;

BEGIN

    if ((${#import[@]})); then
      for p in ${import[@]}; do
        echo "import $p::*;"
      done

      if ((${#include[@]})); then
        echo -e "\n"
      fi
    fi

    if ((${#include[@]})); then
      for i in ${include[@]}; do
        echo "\`include \"$i.svh\""
      done
    fi

    cat <<END

endpackage : $n
END
    ) > $(if [[ $directory ]]; then echo $directory/$n.sv; else echo /dev/stdout; fi)

  done
}


# Function : _ral_dir
#
function _ral_dir
{
  echo $(ral_dir)
}

# Function : ral_dir
#
function ral_dir
{
  echo $(simenv file ral_rfadc_slice_apb3_if.sv | xargs dirname | xargs dirname)
}

# Function : ral_ext
#
function ral_ext
{
  echo $(ral_dir)/ext
}

# Function: ral
#
function _ral
{
  local ral=$(ral_dir)
  local auto=$ral/ext/auto

  # **********************************************
  #                      ADC
  # **********************************************
  simenv reg_model -slice -d $auto  $ral/adc/ral_rfadc_slice_apb3_if.sv; echo
  simenv reg_model -slice -d $auto  $ral/adc/ral_rfadc_subadc_if.sv; echo

  # **********************************************
  #                      DAC
  # **********************************************
  simenv reg_model -slice -d $auto  $ral/dac/ral_rfdac_config.sv; echo

  # **********************************************
  #                     RFCOM
  # **********************************************
  simenv reg_model        -d $auto  $ral/com/ral_rfcom_main_apb_if.sv; echo
  simenv reg_model        -d $auto  $ral/com/ral_rfcom_pll_clk_apb_if.sv; echo

  # **********************************************
  #                      TC
  # **********************************************
  simenv reg_model        -d $auto  $ral/tc/ral_rfams_tc_config.sv

}

# Function: rfams_rg
#
function _rfams_rg
{
  local ext=$(ral_ext)


  # **********************************************
  #                  Postprocess
  # **********************************************

#  simenv add_package  rfams_rg_helper+pkg            \
#                      -d $ext                        \
#                      -import  ral_common_pkg        \
#                      -import  adc_ral_pkg           \
#                      -import  dac_ral_pkg           \
#                      -import  rfams_env_pkg         \
#                      -import  clifden_env_pkg       \
#                      -include auto/rfams_rg_helper


  # Generating remaining include files
  cut -d' ' -f2 $ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%35s = rfadc_reg.&;"  &/e'                   > $ext/auto/ral_rfadc_slice_apb3_if.slice.init.0.svh
  cut -d' ' -f2 $ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%35s = subadc_reg.&;" &/e'                   > $ext/auto/ral_rfadc_subadc_if.slice.init.0.svh

  cut -d' ' -f2 $ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = ral.rfadc_reg_h[k].&;\n"  "&[k]"/e'   > $ext/auto/ral_rfadc_slice_apb3_if.ral.init.dim.1.svh
  cut -d' ' -f2 $ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = ral.subadc_reg_h[k].&;\n" "&[k]"/e'   > $ext/auto/ral_rfadc_subadc_if.ral.init.dim.1.svh

  cut -d' ' -f2 $ext/auto/ral_rfdac_config.decl.0.svh         | cut -d';' -f1 | sed 's/.*/printf  "%35s = rfdac_reg.&;"  &/e'                   > $ext/auto/ral_rfdac_config.slice.init.0.svh
  cut -d' ' -f2 $ext/auto/ral_rfdac_config.decl.0.svh         | cut -d';' -f1 | sed 's/.*/printf  "%46s = ral.rfdac_reg_h[k].&;\n"  "&[k]"/e'   > $ext/auto/ral_rfdac_config.ral.init.0.svh

  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf "%30s = rfcom_reg.&;"     &/e'                 > $ext/auto/ral_rfcom_main_apb_if.init.0.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf "%30s = rfcom_rem_reg.&;" &/e'                 > $ext/auto/ral_rfcom_pll_clk_apb_if.init.0.svh

  cut -d' ' -f2 $ext/auto/ral_rfams_tc_config.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = __tc_ral[id].&;\n"  "tc.&"/e'         > $ext/auto/ral_rfams_tc_config.init.0.svh



  cut -d' ' -f2 $ext/auto/ral_rfams_tc_config.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = __tc_ral[I].&;\n"  "rg.tc.&[I]"/e'  > $ext/auto/ral_rfams_tc_config.assign.svh
  cut -d' ' -f2 $ext/auto/ral_rfams_tc_config.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.tc.&[I];\n"      "tc.&"/e'       > $ext/auto/ral_rfams_tc_config.assign.case.0.svh


  cut -d' ' -f2 $ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = __adc_ral[I][J].rfadc_reg_h[K].&;\n"  "rg.adc.&[I][J][K]"/e' > $ext/auto/ral_rfadc_slice_apb3_if.assign.svh
  cut -d' ' -f2 $ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = __adc_ral[I][J].subadc_reg_h[K].&;\n" "rg.adc.&[I][J][K]"/e' > $ext/auto/ral_rfadc_subadc_if.assign.svh

  cut -d' ' -f2 $ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "a.&[J][K]"/e'  > $ext/auto/ral_rfadc_slice_apb3_if.assign.case.0.svh
  cut -d' ' -f2 $ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "a.&[J][K]"/e'  > $ext/auto/ral_rfadc_subadc_if.assign.case.0.svh

  cut -d' ' -f2 $ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "rg.&[I][J][K]"/e'  > $ext/auto/ral_rfadc_slice_apb3_if.assign.case.1.svh
  cut -d' ' -f2 $ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "rg.&[I][J][K]"/e'  > $ext/auto/ral_rfadc_subadc_if.assign.case.1.svh

  cut -d' ' -f2 $ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.&[I][J][K];\n" "&[K]"/e' > $ext/auto/ral_rfadc_slice_apb3_if.assign.case.2.svh
  cut -d' ' -f2 $ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.&[I][J][K];\n" "&[K]"/e' > $ext/auto/ral_rfadc_subadc_if.assign.case.2.svh

  cut -d' ' -f2 $ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "a.&[K]"/e' > $ext/auto/ral_rfadc_slice_apb3_if.assign.case.3.svh
  cut -d' ' -f2 $ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "a.&[K]"/e' > $ext/auto/ral_rfadc_subadc_if.assign.case.3.svh


  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = __adc_ral[I][J].rfcom_reg_h.&;\n"     "rg.adc.com.&[I][J]"/e' > $ext/auto/ral_rfcom_main_apb_if.adc.assign.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = __adc_ral[I][J].rfcom_rem_reg_h.&;\n" "rg.adc.com.&[I][J]"/e' > $ext/auto/ral_rfcom_pll_clk_apb_if.adc.assign.svh

  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n"  "com.adc.&[J]"/e'   > $ext/auto/ral_rfcom_main_apb_if.adc.assign.case.0.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n"  "com.adc.&[J]"/e'   > $ext/auto/ral_rfcom_pll_clk_apb_if.adc.assign.case.0.svh

  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n"  "rg.com.&[I][J]"/e' > $ext/auto/ral_rfcom_main_apb_if.adc.assign.case.1.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n"  "rg.com.&[I][J]"/e' > $ext/auto/ral_rfcom_pll_clk_apb_if.adc.assign.case.1.svh

  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.com.&[I][J];\n"      "com.&"/e'          > $ext/auto/ral_rfcom_main_apb_if.adc.assign.case.2.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.com.&[I][J];\n"      "com.&"/e'          > $ext/auto/ral_rfcom_pll_clk_apb_if.adc.assign.case.2.svh

  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n"  "com.adc.&"/e'      > $ext/auto/ral_rfcom_main_apb_if.adc.assign.case.3.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n"  "com.adc.&"/e'      > $ext/auto/ral_rfcom_pll_clk_apb_if.adc.assign.case.3.svh


  cut -d' ' -f2 $ext/auto/ral_rfdac_config.decl.0.svh         | cut -d';' -f1 | sed 's/.*/printf  "%46s = __dac_ral[I][K].rfdac_reg_h[K].&;\n"  "rg.dac.&[I][J][K]"/e'  > $ext/auto/ral_rfdac_config.assign.svh
  cut -d' ' -f2 $ext/auto/ral_rfdac_config.decl.0.svh         | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.&[I][J][K];\n"   "d.&[J][K]"/e'      > $ext/auto/ral_rfdac_config.assign.case.0.svh
  cut -d' ' -f2 $ext/auto/ral_rfdac_config.decl.0.svh         | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.&[I][J][K];\n"   "rg.&[I][J][K]"/e'  > $ext/auto/ral_rfdac_config.assign.case.1.svh
  cut -d' ' -f2 $ext/auto/ral_rfdac_config.decl.0.svh         | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.&[I][J][K];\n"       "&[K]"/e'           > $ext/auto/ral_rfdac_config.assign.case.2.svh
  cut -d' ' -f2 $ext/auto/ral_rfdac_config.decl.0.svh         | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.&[I][J][K];\n"   "d.&[K]"/e'         > $ext/auto/ral_rfdac_config.assign.case.3.svh

  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = __dac_ral[I][J].rfcom_reg_h.&;\n"     "rg.dac.com.&[I][J]"/e' > $ext/auto/ral_rfcom_main_apb_if.dac.assign.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = __dac_ral[I][J].rfcom_rem_reg_h.&;\n" "rg.dac.com.&[I][J]"/e' > $ext/auto/ral_rfcom_pll_clk_apb_if.dac.assign.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n"  "com.dac.&[J]"/e'   > $ext/auto/ral_rfcom_main_apb_if.dac.assign.case.0.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n"  "com.dac.&[J]"/e'   > $ext/auto/ral_rfcom_pll_clk_apb_if.dac.assign.case.0.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n"  "rg.com.&[I][J]"/e' > $ext/auto/ral_rfcom_main_apb_if.dac.assign.case.1.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n"  "rg.com.&[I][J]"/e' > $ext/auto/ral_rfcom_pll_clk_apb_if.dac.assign.case.1.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.com.&[I][J];\n"      "com.&"/e'          > $ext/auto/ral_rfcom_main_apb_if.dac.assign.case.2.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.com.&[I][J];\n"      "com.&"/e'          > $ext/auto/ral_rfcom_pll_clk_apb_if.dac.assign.case.2.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n"  "com.dac.&"/e'      > $ext/auto/ral_rfcom_main_apb_if.dac.assign.case.3.svh
  cut -d' ' -f2 $ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n"  "com.dac.&"/e'      > $ext/auto/ral_rfcom_pll_clk_apb_if.dac.assign.case.3.svh


  cat <<PACKAGE > $ext/auto/rfams_rg.svh

\`define num_adc_eq(count)  \`define NUM_ADC_EQ_\`\`count
\`define num_dac_eq(count)  \`define NUM_DAC_EQ_\`\`count
\`define num_adc_dac_eq(adcount, dacount) \`define  NUM_ADC_EQ_\`\`adcount\`\`__NUM_DAC_EQ_\`\`dacount

\`ifdef TB_NUM_ADC
  \`num_adc_eq(\`TB_NUM_ADC)

  \`ifdef TB_NUM_DAC
    \`num_dac_eq(\`TB_NUM_DAC)
    \`num_adc_dac_eq(\`TB_NUM_ADC, \`TB_NUM_DAC)
  \`else
    \`num_dac_eq(0)
    \`num_adc_dac_eq(\`TB_NUM_ADC, 0)
  \`endif

\`else
  \`num_adc_eq(0)

  \`ifdef TB_NUM_DAC
    \`num_dac_eq(\`TB_NUM_DAC)
    \`num_adc_dac_eq(0, \`TB_NUM_DAC)
  \`endif

\`endif


\`ifdef NUM_ADC_EQ_1__NUM_DAC_EQ_0
  \`define TB_ADC_ONLY

\`elsif NUM_ADC_EQ_0__NUM_DAC_EQ_1
  \`define TB_DAC_ONLY

\`else
  \`define TB_TOP
\`endif


\`ifdef TB_NUM_ADC
adc_ral __adc_ral[$][$];

// Function: set_adc_ral
//
function automatic void set_adc_ral(adc_ral ral, int i, int j);
  \`uvm_info("SET_ADC_RAL", \$sformatf("ral=%h, i=%0d, j=%0d", ral, i, j), UVM_LOW)

  \$cast(__adc_ral[i][j], ral);
endfunction : set_adc_ral
\`endif


\`ifdef TB_NUM_DAC
dac_ral __dac_ral[$][$];

// Function: set_dac_ral
//
function automatic void set_dac_ral(dac_ral ral, int i, int j);
  \`uvm_info("SET_DAC_RAL", \$sformatf("ral=%h, i=%0d, j=%0d", ral, i, j), UVM_LOW)

  \$cast(__dac_ral[i][j], ral);
endfunction : set_dac_ral
\`endif


\`ifdef TB_TOP
ral_block_rfams_tc_config_rfams_tc_config_bank  __tc_ral[$];

// Function: set_tc_ral
//
function automatic void set_tc_ral(ral_block_rfams_tc_config_rfams_tc_config_bank ral, int i);
  \`uvm_info("SET_TC_RAL", \$sformatf("ral=%h, i=%0d", ral, i), UVM_LOW)

  \$cast(__tc_ral[i], ral);
endfunction : set_tc_ral
\`endif


typedef class rfams_t;
typedef class rfcom_t;

uvm_object_string_pool #(rfams_t) rfams_cache = new;

// Class: com_dim_2_t
//
class com_dim_2_t;
\`include "auto/ral_rfcom_main_apb_if.decl.2.svh"
\`include "auto/ral_rfcom_pll_clk_apb_if.decl.2.svh"
endclass : com_dim_2_t;


\`ifdef TB_NUM_ADC

typedef class rfadc_slice_t;
typedef class rfadc_ral_t;

uvm_object_string_pool #(rfadc_slice_t) adc_slice_cache = new;
uvm_object_string_pool #(rfadc_ral_t)         adc_cache = new;

// Class: rfadc_slice_t
//
class rfadc_slice_t extends uvm_object;
int id = -1;
//rfadc_ral_t up;

ral_block_rfadc_slice_apb3_if_rfadc_slice_apb3_if_bank  rfadc_reg;
ral_block_rfadc_subadc_if_rfadc_subadc_if_bank          subadc_reg;

\`include "auto/ral_rfadc_slice_apb3_if.decl.0.svh"
\`include "auto/ral_rfadc_subadc_if.decl.0.svh"

// Function: new
//
function new(string name="");
  super.new(name);
endfunction : new

// Function: initialize
//
function void initialize;
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf "%35s = rfadc_reg.&;"  &/e')
\`include "auto/ral_rfadc_slice_apb3_if.slice.init.0.svh"

// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf "%35s = subadc_reg.&;" &/e')
\`include "auto/ral_rfadc_subadc_if.slice.init.0.svh"
endfunction : initialize

endclass : rfadc_slice_t

// Class: rfadc_ral_t
//
class rfadc_ral_t extends uvm_object;
int         id = -1;
adc_ral     ral;
//rfams_t   up;
rfcom_t     com = new;

// Function: slice
//
function rfadc_slice_t slice(int k=0);
  string key = \$sformatf("adc%0d_slice%0d", id, k);

  if (!(k inside {[0:3]})) \`uvm_fatal("SLICEINDEXERROR", \$sformatf("slice index '%0d' not in range [0:3]", k))

  slice = adc_slice_cache.get(key);

  if (slice.id == -1) begin // new
    slice.id  = k;
    //slice.up  = this;
    slice.rfadc_reg  = ral.rfadc_reg_h[k];
    slice.subadc_reg = ral.subadc_reg_h[k];

    slice.initialize;
  end
endfunction : slice

// Function: init_com
//
local function rfcom_t init_com;
  com.rfcom_reg     = ral.rfcom_reg_h;
  com.rfcom_rem_reg = ral.rfcom_rem_reg_h;

  com.initialize;
endfunction : init_com

\`include "auto/ral_rfadc_slice_apb3_if.decl.1.svh"
\`include "auto/ral_rfadc_subadc_if.decl.1.svh"

// Function: new
//
function new(string name="");
  super.new(name);
endfunction : new

// Function: initialize
//
function void initialize;
  foreach (ral.rfadc_reg_h[k]) begin
    slice(k);

    // adc(J).REG[K] ≡ adc(J).slice(K).REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = ral.rfadc_reg_h[k].&;\n"  "&[k]"/e')
\`include "auto/ral_rfadc_slice_apb3_if.ral.init.dim.1.svh"

// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = ral.subadc_reg_h[k].&;\n" "&[k]"/e')
\`include "auto/ral_rfadc_subadc_if.ral.init.dim.1.svh"

  end

  init_com();
endfunction : initialize

endclass : rfadc_ral_t


\`ifdef TB_ADC_ONLY
// Function: slice
//
function automatic rfadc_slice_t slice(int k=0);
  slice = adc(0).slice(k);
endfunction : slice
\`endif   // TB_ADC_ONLY


// Function: adc
//
function automatic rfadc_ral_t adc(int j=0);
   adc = ams(0).adc(j);
endfunction : adc


// Class: adc_t
//
class adc_t;
com_dim_2_t com = new;

\`include "auto/ral_rfadc_slice_apb3_if.decl.3.svh"
\`include "auto/ral_rfadc_subadc_if.decl.3.svh"
endclass : adc_t;


\`ifndef  NUM_ADC_EQ_1    // ADC=2,...

  struct {
    \`include "auto/ral_rfadc_slice_apb3_if.decl.2.svh"
    \`include "auto/ral_rfadc_subadc_if.decl.2.svh"
  } a;

\`elsif   NUM_DAC_EQ_0    // ADC=1, DAC=0

  \`include "auto/ral_rfadc_slice_apb3_if.decl.1.svh"
  \`include "auto/ral_rfadc_subadc_if.decl.1.svh"

\`elsif   NUM_DAC_EQ_1    // ADC=1, DAC=1

  struct {
    \`include "auto/ral_rfadc_slice_apb3_if.decl.1.svh"
    \`include "auto/ral_rfadc_subadc_if.decl.1.svh"
  } a;

\`endif


\`endif   // TB_NUM_ADC



\`ifdef TB_NUM_DAC

typedef class rfdac_slice_t;
typedef class rfdac_ral_t;

uvm_object_string_pool #(rfdac_slice_t) dac_slice_cache = new;
uvm_object_string_pool #(rfdac_ral_t)       dac_cache   = new;

// Class: rfdac_slice_t
//
class rfdac_slice_t extends uvm_object;
int id = -1;
//rfdac_ral_t up;

ral_block_rfdac_config_rfdac_config_bank  rfdac_reg;

\`include "auto/ral_rfdac_config.decl.0.svh"

// Function: new
//
function new(string name="");
  super.new(name);
endfunction : new

// Function: initialize
//
function void initialize;
// \$(cut -d' ' -f2 \$ext/auto/ral_rfdac_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf "%35s = rfdac_reg.&;"  &/e')
\`include "auto/ral_rfdac_config.slice.init.0.svh"
endfunction : initialize

endclass : rfdac_slice_t

// Class: rfdac_ral_t
//
class rfdac_ral_t extends uvm_object;
int         id = -1;
dac_ral     ral;
//rfams_t   up;
rfcom_t     com = new;

// Function: slice
//
function rfdac_slice_t slice(int k=0);
  string key = \$sformatf("dac%0d_slice%0d", id, k);

  if (!(k inside {[0:3]})) \`uvm_fatal("SLICEINDEXERROR", \$sformatf("slice index '%0d' not in range [0:3]", k))

  slice = dac_slice_cache.get(key);

  if (slice.id == -1) begin // new
    slice.id  = k;
    //slice.up  = this;
    slice.rfdac_reg  = ral.rfdac_reg_h[k];

    slice.initialize;
  end
endfunction : slice

// Function: init_com
//
local function rfcom_t init_com;
  com.rfcom_reg     = ral.rfcom_reg_h;
  com.rfcom_rem_reg = ral.rfcom_rem_reg_h;

  com.initialize;
endfunction : init_com

\`include "auto/ral_rfdac_config.decl.1.svh"

// Function: new
//
function new(string name="");
  super.new(name);
endfunction : new

// Function: initialize
//
function void initialize;
  foreach (ral.rfdac_reg_h[k]) begin
    slice(k);

    // dac(J).REG[K] ≡ dac(J).slice(K).REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfdac_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = ral.rfdac_reg_h[k].&;\n"  "&[k]"/e')
\`include "auto/ral_rfdac_config.ral.init.0.svh"

  end

  init_com();
endfunction : initialize

endclass : rfdac_ral_t


\`ifdef TB_DAC_ONLY
// Function: slice
//
function automatic rfdac_slice_t slice(int k=0);
  slice = dac(0).slice(k);
endfunction : slice
\`endif   // TB_DAC_ONLY


// Function: dac
//
function automatic rfdac_ral_t dac(int j=0);
   dac = ams(0).dac(j);
endfunction : dac


// Class: dac_t
//
class dac_t;
com_dim_2_t com = new;

\`include "auto/ral_rfdac_config.decl.3.svh"
endclass : dac_t;


\`ifndef  NUM_DAC_EQ_1    // DAC=2,...

  struct {
    \`include "auto/ral_rfdac_config.decl.2.svh"
  } d;

\`elsif   NUM_ADC_EQ_0    // DAC=1, ADC=0

  \`include "auto/ral_rfdac_config.decl.1.svh"

\`elsif   NUM_ADC_EQ_1    // DAC=1, ADC=1

  struct {
    \`include "auto/ral_rfdac_config.decl.1.svh"
  } d;

\`endif


\`endif   // TB_NUM_DAC


\`ifdef TB_TOP
struct
{
  \`include "auto/ral_rfams_tc_config.decl.0.svh"
} tc;
\`endif

// Class: rfcom_t
//
class rfcom_t;

ral_block_rfcom_main_apb_if_rfcom_main_apb_if_bank        rfcom_reg;
ral_block_rfcom_pll_clk_apb_if_rfcom_pll_clk_apb_if_bank  rfcom_rem_reg;

\`include "auto/ral_rfcom_main_apb_if.decl.0.svh"
\`include "auto/ral_rfcom_pll_clk_apb_if.decl.0.svh"

// Function: initialize
//
function void initialize;
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf "%30s = rfcom_reg.&;"     &/e')
\`include "auto/ral_rfcom_main_apb_if.init.0.svh"

// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf "%30s = rfcom_rem_reg.&;" &/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.init.0.svh"
endfunction : initialize

endclass : rfcom_t


// Class: rfams_t
//
class rfams_t extends uvm_object;
int id = -1;
//rfams_env env;

// Function: new
//
function new(string name="");
  super.new(name);
endfunction : new

\`ifdef TB_NUM_ADC
// Function: adc
//
function rfadc_ral_t adc(int j=0);
  string key = \$sformatf("adc%0d", j);

  adc = adc_cache.get(key);
  if (adc.id == -1) begin
    adc.id  = j;
    //adc.up  = this;

  \`ifdef   NUM_DAC_EQ_0    // ADC=1, DAC=0

    adc.ral = __adc_ral[id][j];

  \`else

    adc.ral = __adc_ral[id][j];

  \`endif

    adc.initialize;
  end
endfunction : adc
\`endif   // TB_NUM_ADC


\`ifdef TB_NUM_DAC
// Function: dac
//
function rfdac_ral_t dac(int j=0);
  string key = \$sformatf("dac%0d", j);

  dac = dac_cache.get(key);
  if (dac.id == -1) begin
    dac.id  = j;
    //dac.up  = this;

  \`ifdef   NUM_ADC_EQ_0    // DAC=1, ADC=0

    dac.ral = __dac_ral[id][j];

  \`else

    dac.ral = __dac_ral[id][j];

  \`endif

    dac.initialize;
  end
endfunction : dac
\`endif   // TB_NUM_DAC

\`ifdef TB_TOP
struct {
  \`include "auto/ral_rfams_tc_config.decl.0.svh"
} tc;

// Function: initialize
//
function void initialize;
  // ams(I).tc.REG ≡ TC_RAL(I).REG                                                                       =              __tc_ral[id].&
// \$(cut -d' ' -f2 \$ext/auto/ral_rfams_tc_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = env.rfams_ral_h.tc_bank_h.&;\n"  "tc.&"/e')
\`include "auto/ral_rfams_tc_config.init.0.svh"
endfunction : initialize

\`endif   // TB_TOP

endclass : rfams_t


// Function: ams
//
function automatic rfams_t ams(int i=0);
  string  key = \$sformatf("ams%0d", i);

  ams = rfams_cache.get(key);
  if (ams.id == -1) begin
    // clifden_env top_env = uvm_utils #(clifden_env)::find(uvm_top.top_levels[0]); //uvm_test_top;

    ams.id  = i;
    // ams.env = top_env.rfams_env_h[i];

\`ifdef TB_TOP
    ams.initialize;
\`endif // TB_TOP

  end
endfunction : ams


// Class: com_t
//
class com_t;
\`ifdef TB_NUM_ADC
  \`ifndef  NUM_ADC_EQ_1    // ADC=2,...

    struct {
      \`include "auto/ral_rfcom_main_apb_if.decl.1.svh"
      \`include "auto/ral_rfcom_pll_clk_apb_if.decl.1.svh"
    } adc;

  \`elsif   NUM_DAC_EQ_0    // ADC=1, DAC=0

    \`include "auto/ral_rfcom_main_apb_if.decl.0.svh"
    \`include "auto/ral_rfcom_pll_clk_apb_if.decl.0.svh"

  \`elsif   NUM_DAC_EQ_1    // ADC=1, DAC=1

    struct {
      \`include "auto/ral_rfcom_main_apb_if.decl.0.svh"
      \`include "auto/ral_rfcom_pll_clk_apb_if.decl.0.svh"
    } adc;

  \`endif
\`endif   // TB_NUM_ADC


\`ifdef TB_NUM_DAC
  \`ifndef  NUM_DAC_EQ_1    // DAC=2,...

    struct {
      \`include "auto/ral_rfcom_main_apb_if.decl.1.svh"
      \`include "auto/ral_rfcom_pll_clk_apb_if.decl.1.svh"
    } dac;

  \`elsif   NUM_ADC_EQ_0    // DAC=1, ADC=0

    \`include "auto/ral_rfcom_main_apb_if.decl.0.svh"
    \`include "auto/ral_rfcom_pll_clk_apb_if.decl.0.svh"

  \`elsif   NUM_ADC_EQ_1    // DAC=1, ADC=1

    struct {
      \`include "auto/ral_rfcom_main_apb_if.decl.0.svh"
      \`include "auto/ral_rfcom_pll_clk_apb_if.decl.0.svh"
    } dac;

  \`endif
\`endif   // TB_NUM_DAC

endclass : com_t;
com_t com = new;


// Class: rg_t
//
class rg_t;
\`ifdef TB_NUM_ADC
  adc_t adc = new;

  \`ifndef  NUM_ADC_EQ_1    // ADC=2,...
  \`elsif   NUM_DAC_EQ_0    // ADC=1, DAC=0

    \`include "auto/ral_rfadc_slice_apb3_if.decl.3.svh"
    \`include "auto/ral_rfadc_subadc_if.decl.3.svh"

    com_dim_2_t com = new;

  \`elsif   NUM_DAC_EQ_1    // ADC=1, DAC=1
  \`endif
\`endif   // TB_NUM_ADC


\`ifdef TB_NUM_DAC
  dac_t dac = new;

  \`ifndef  NUM_DAC_EQ_1    // DAC=2,...
  \`elsif   NUM_ADC_EQ_0    // DAC=1, ADC=0

    \`include "auto/ral_rfdac_config.decl.3.svh"

    com_dim_2_t com = new;

  \`elsif   NUM_ADC_EQ_1    // DAC=1, ADC=1
  \`endif
\`endif   // TB_NUM_DAC

\`ifdef TB_TOP
  struct
  {
    \`include "auto/ral_rfams_tc_config.decl.1.svh"
  } tc;
\`endif

endclass : rg_t
rg_t  rg = new;



// Class: rfams_rg_init
//
class rfams_rg_init extends uvm_component;
// Function: new
//
function new(string name="rfams_rg_init", uvm_component parent=null);
  super.new(name, parent);
endfunction : new


// Function: end_of_elaboration_phase
//
function void end_of_elaboration_phase (uvm_phase phase);
  super.end_of_elaboration_phase(phase);

  for (int I=0; I < \`TB_NUM_RFAMS; I++) begin : RFAMS_ENV_ITER

\`ifdef TB_TOP
    // rg.tc.REG[I] ≡ TC_RAL(I).REG ≡ ams(I).tc.REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfams_tc_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = \`TC_RAL(I).&;\n"  "rg.tc.&[I]"/e')
\`include "auto/ral_rfams_tc_config.assign.svh"

    // tc.REG ≡ rg.tc.&[I] when I=0
    if (I == 0) begin
// \$(cut -d' ' -f2 \$ext/auto/ral_rfams_tc_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.tc.&[I];\n"  "tc.&"/e')
\`include "auto/ral_rfams_tc_config.assign.case.0.svh"

    end
\`endif

\`ifdef TB_NUM_ADC
    foreach (__adc_ral[I][J])  begin : ADC
      ams(I).adc(J);

      // -------
      //  SLICE
      // -------
      foreach (__adc_ral[I][J].rfadc_reg_h[K]) begin : SLICE

        // rg.adc.REG[I][J][K] ≡ ams(I).adc(J).slice(K).REG ≡ RFADC_RAL(I, J).rfadc_reg_h[K].REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = \`RFADC_RAL(I, J).rfadc_reg_h[K].&;\n"  "rg.adc.&[I][J][K]"/e')
\`include "auto/ral_rfadc_slice_apb3_if.assign.svh"

        // rg.adc.REG[I][J][K] ≡ ams(I).adc(J).slice(K).REG ≡ RFADC_RAL(I, J).subadc_reg_h[K].REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = \`RFADC_RAL(I, J).subadc_reg_h[K].&;\n" "rg.adc.&[I][J][K]"/e')
\`include "auto/ral_rfadc_subadc_if.assign.svh"


  \`ifndef NUM_ADC_EQ_1   // ADC=2,...

        // a.REG[J][K] ≡ rg.adc.REG[0][J][K] ≡ adc(J).slice(K).REG when I=0
        if (I == 0) begin : REG_K
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "a.&[J][K]"/e')
\`include "auto/ral_rfadc_slice_apb3_if.assign.case.0.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "a.&[J][K]"/e')
\`include "auto/ral_rfadc_subadc_if.assign.case.0.svh"
        end : REG_K

  \`elsif NUM_DAC_EQ_0    // ADC=1, DAC=0

        // rg.REG[I][J][K] ≡ rg.adc.REG[I][J][K]
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "rg.&[I][J][K]"/e')
\`include "auto/ral_rfadc_slice_apb3_if.assign.case.1.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "rg.&[I][J][K]"/e')
\`include "auto/ral_rfadc_subadc_if.assign.case.1.svh"

        // REG[K] ≡ rg.REG[0][0][K] ≡ ams(0).adc(0).slice(K).REG ≡ adc(0).slice(K).REG ≡ slice(K).REG when I=0, J=0
        if (I == 0 && J == 0) begin : REG_K
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.&[I][J][K];\n" "&[K]"/e')
\`include "auto/ral_rfadc_slice_apb3_if.assign.case.2.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.&[I][J][K];\n" "&[K]"/e')
\`include "auto/ral_rfadc_subadc_if.assign.case.2.svh"
        end : REG_K

  \`elsif NUM_DAC_EQ_1    // ADC=1, DAC=1

        // a.REG[K] ≡ rg.adc.REG[0][0][K] ≡ adc(0).slice(K).REG ≡ adc(0).REG[K] when I=0, J=0
        if (I == 0 && J == 0) begin : REG_K
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_slice_apb3_if.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "a.&[K]"/e')
\`include "auto/ral_rfadc_slice_apb3_if.assign.case.3.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfadc_subadc_if.decl.0.svh      | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.&[I][J][K];\n" "a.&[K]"/e')
\`include "auto/ral_rfadc_subadc_if.assign.case.3.svh"
        end : REG_K

  \`endif

      end : SLICE



      // -----
      //  COM
      // -----

      // rg.adc.com.REG[I][J] ≡ RFADC_RAL(I, J).rfcom_reg_h.REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf "%46s = \`RFADC_RAL(I, J).rfcom_reg_h.&;\n"     "rg.adc.com.&[I][J]"/e')
\`include "auto/ral_rfcom_main_apb_if.adc.assign.svh"
      // rg.adc.com.REG[I][J] ≡ RFADC_RAL(I, J).rfcom_rem_reg_h.REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf "%46s = \`RFADC_RAL(I, J).rfcom_rem_reg_h.&;\n" "rg.adc.com.&[I][J]"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.adc.assign.svh"


  \`ifndef NUM_ADC_EQ_1   // ADC=2,...

      // com.adc.REG[J] ≡ rg.adc.com.REG[0][J], J=0,1,...  when I=0, J=0
      if (I == 0) begin : com_REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n" "com.adc.&[J]"/e')
\`include "auto/ral_rfcom_main_apb_if.adc.assign.case.0.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n" "com.adc.&[J]"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.adc.assign.case.0.svh"
      end : com_REG

  \`elsif NUM_DAC_EQ_0    // ADC=1, DAC=0

      // rg.com.REG[I][J] ≡ rg.adc.com.REG[I][J]
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf "%46s = rg.adc.com.&[I][J];\n"    "rg.com.&[I][J]"/e')
\`include "auto/ral_rfcom_main_apb_if.adc.assign.case.1.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf "%46s = rg.adc.com.&[I][J];\n" "rg.com.&[I][J]"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.adc.assign.case.1.svh"

      // com.REG ≡ rg.com.REG[0][0] when I=0, J=0
      if (I == 0 && J == 0) begin : com_REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.com.&[I][J];\n" "com.&"/e')
\`include "auto/ral_rfcom_main_apb_if.adc.assign.case.2.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.com.&[I][J];\n" "com.&"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.adc.assign.case.2.svh"
      end : com_REG

  \`elsif NUM_DAC_EQ_1    // ADC=1, DAC=1

      // com.adc.REG ≡ rg.adc.com.REG[0][0] when I=0, J=0
      if (I == 0 && J == 0) begin : com_REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n" "com.adc.&"/e')
\`include "auto/ral_rfcom_main_apb_if.adc.assign.case.3.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.adc.com.&[I][J];\n" "com.adc.&"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.adc.assign.case.3.svh"
      end : com_REG

  \`endif

    end : ADC

\`endif // TB_NUM_ADC



\`ifdef TB_NUM_DAC
    foreach (__dac_ral[I][J])  begin : DAC
      ams(I).dac(J);

      // -------
      //  SLICE
      // -------
      foreach (__dac_ral[I][J].rfdac_reg_h[K]) begin : SLICE

        // rg.dac.REG[I][J][K] ≡ ams(I).dac(J).slice(K).REG ≡ RFDAC_RAL(I, J).rfdac_reg_h[K].REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfdac_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = \`RFDAC_RAL(I, J).rfdac_reg_h[K].&;\n"  "rg.dac.&[I][J][K]"/e')
\`include "auto/ral_rfdac_config.assign.svh"


  \`ifndef NUM_DAC_EQ_1   // DAC=2,...

        // d.REG[J][K] ≡ rg.dac.REG[0][J][K] ≡ dac(J).slice(K).REG when I=0
        if (I == 0) begin : REG_K
// \$(cut -d' ' -f2 \$ext/auto/ral_rfdac_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.&[I][J][K];\n" "d.&[J][K]"/e')
\`include "auto/ral_rfdac_config.assign.case.0.svh"
        end : REG_K

  \`elsif NUM_ADC_EQ_0    // DAC=1, ADC=0

        // rg.REG[I][J][K] ≡ rg.dac.REG[I][J][K]
// \$(cut -d' ' -f2 \$ext/auto/ral_rfdac_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.&[I][J][K];\n" "rg.&[I][J][K]"/e')
\`include "auto/ral_rfdac_config.assign.case.1.svh"

        // REG[K] ≡ rg.REG[0][0][K] ≡ ams(0).dac(0).slice(K).REG ≡ dac(0).slice(K).REG ≡ slice(K).REG when I=0, J=0
        if (I == 0 && J == 0) begin : REG_K
// \$(cut -d' ' -f2 \$ext/auto/ral_rfdac_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.&[I][J][K];\n" "&[K]"/e')
\`include "auto/ral_rfdac_config.assign.case.2.svh"
        end : REG_K

  \`elsif NUM_ADC_EQ_1    // DAC=1, ADC=1

        // d.REG[K] ≡ rg.dac.REG[0][0][K] ≡ dac(0).slice(K).REG ≡ dac(0).REG[K] when I=0, J=0
        if (I == 0 && J == 0) begin : REG_K
// \$(cut -d' ' -f2 \$ext/auto/ral_rfdac_config.decl.0.svh  | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.&[I][J][K];\n" "d.&[K]"/e')
\`include "auto/ral_rfdac_config.assign.case.3.svh"
        end : REG_K

  \`endif

      end : SLICE



      // -----
      //  COM
      // -----

      // rg.dac.com.REG[I][J] ≡ RFDAC_RAL(I, J).rfcom_reg_h.REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf "%46s = \`RFDAC_RAL(I, J).rfcom_reg_h.&;\n"     "rg.dac.com.&[I][J]"/e')
\`include "auto/ral_rfcom_main_apb_if.dac.assign.svh"

      // rg.dac.com.REG[I][J] ≡ RFDAC_RAL(I, J).rfcom_rem_reg_h.REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf "%46s = \`RFDAC_RAL(I, J).rfcom_rem_reg_h.&;\n" "rg.dac.com.&[I][J]"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.dac.assign.svh"


  \`ifndef NUM_DAC_EQ_1   // DAC=2,...

      // com.dac.REG[J] ≡ rg.dac.com.REG[0][J], J=0,1,... when I=0, J=0
      if (I == 0) begin : com_REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n" "com.dac.&[J]"/e')
\`include "auto/ral_rfcom_main_apb_if.dac.assign.case.0.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n" "com.dac.&[J]"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.dac.assign.case.0.svh"
      end : com_REG

  \`elsif NUM_ADC_EQ_0    // DAC=1, ADC=0

      // rg.com.REG[I][J] ≡ rg.dac.com.REG[I][J]
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf "%46s = rg.dac.com.&[I][J];\n"    "rg.com.&[I][J]"/e')
\`include "auto/ral_rfcom_main_apb_if.dac.assign.case.1.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf "%46s = rg.dac.com.&[I][J];\n" "rg.com.&[I][J]"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.dac.assign.case.1.svh"

      // com.REG ≡ rg.com.REG[0][0] when I=0, J=0
      if (I == 0 && J == 0) begin : com_REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.com.&[I][J];\n" "com.&"/e')
\`include "auto/ral_rfcom_main_apb_if.dac.assign.case.2.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.com.&[I][J];\n" "com.&"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.dac.assign.case.2.svh"
      end : com_REG

  \`elsif NUM_ADC_EQ_1    // DAC=1, ADC=1

      // com.dac.REG ≡ rg.dac.com.REG[0][0] when I=0, J=0
      if (I == 0 && J == 0) begin : com_REG
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_main_apb_if.decl.0.svh    | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n" "com.dac.&"/e')
\`include "auto/ral_rfcom_main_apb_if.dac.assign.case.3.svh"
// \$(cut -d' ' -f2 \$ext/auto/ral_rfcom_pll_clk_apb_if.decl.0.svh | cut -d';' -f1 | sed 's/.*/printf  "%46s = rg.dac.com.&[I][J];\n" "com.dac.&"/e')
\`include "auto/ral_rfcom_pll_clk_apb_if.dac.assign.case.3.svh"
      end : com_REG

  \`endif

    end : DAC

\`endif // TB_NUM_DAC

  end : RFAMS_ENV_ITER
endfunction : end_of_elaboration_phase

endclass : rfams_rg_init

rfams_rg_init __INIT__ = new;

\`undef NUM_ADC_EQ_0
\`undef NUM_ADC_EQ_1
\`undef NUM_ADC_EQ_2
\`undef NUM_DAC_EQ_0
\`undef NUM_DAC_EQ_1
\`undef NUM_DAC_EQ_2
\`undef NUM_ADC_EQ_0__NUM_DAC_EQ_1
\`undef NUM_ADC_EQ_1__NUM_DAC_EQ_0
\`undef NUM_ADC_EQ_2__NUM_DAC_EQ_2
\`undef NUM_ADC_EQ_1__NUM_DAC_EQ_1
\`undef TB_ADC_ONLY
\`undef TB_DAC_ONLY
\`undef TB_TOP
\`undef num_adc_eq
\`undef num_dac_eq
\`undef num_adc_dac_eq

PACKAGE



  cat <<PACKAGE > $ext/auto/rfams_rg_helper.svh

\`define num_adc_eq(count)  \`define NUM_ADC_EQ_\`\`count
\`define num_dac_eq(count)  \`define NUM_DAC_EQ_\`\`count
\`define num_adc_dac_eq(adcount, dacount) \`define  NUM_ADC_EQ_\`\`adcount\`\`__NUM_DAC_EQ_\`\`dacount

\`ifdef TB_NUM_ADC
  \`num_adc_eq(\`TB_NUM_ADC)

  \`ifdef TB_NUM_DAC
    \`num_dac_eq(\`TB_NUM_DAC)
    \`num_adc_dac_eq(\`TB_NUM_ADC, \`TB_NUM_DAC)
  \`else
    \`num_dac_eq(0)
    \`num_adc_dac_eq(\`TB_NUM_ADC, 0)
  \`endif

\`else
  \`num_adc_eq(0)

  \`ifdef TB_NUM_DAC
    \`num_dac_eq(\`TB_NUM_DAC)
    \`num_adc_dac_eq(0, \`TB_NUM_DAC)
  \`endif

\`endif


\`ifdef NUM_ADC_EQ_1__NUM_DAC_EQ_0
  \`define TB_ADC_ONLY

\`elsif NUM_ADC_EQ_0__NUM_DAC_EQ_1
  \`define TB_DAC_ONLY

\`else
  \`define TB_TOP
\`endif


// I = rfams instance ID
// J = rfadc/dac env instance ID or adc/dac_ral ID
//
\`ifdef TB_ADC_ONLY

  \`define ADC_ITER(I, J)   top_env.rfams_env_h[I].adc_env_h[J]
  \`define RFADC_RAL(I, J)  \`ADC_ITER(I, J).adc_ral_h

\`elsif TB_DAC_ONLY

  \`define DAC_ITER(I, J)   top_env.rfams_env_h[I].dac_env_h[J]
  \`define RFDAC_RAL(I, J)  \`DAC_ITER(I, J).dac_ral_h

// TOPOLOGY = RFAMS
\`else

  \`define ADC_ITER(I, J)   top_env.rfams_env_h[I].rfams_ral_h.adc_ral_h[J]
  \`define DAC_ITER(I, J)   top_env.rfams_env_h[I].rfams_ral_h.dac_ral_h[J]
  \`define RFADC_RAL(I, J)  \`ADC_ITER(I, J)
  \`define RFDAC_RAL(I, J)  \`DAC_ITER(I, J)
  \`define TC_RAL(I)        top_env.rfams_env_h[I].rfams_ral_h.tc_bank_h

\`endif


// Class: rfams_rg_helper_init
//
class rfams_rg_helper_init extends uvm_component;
// Function: new
//
function new(string name="rfams_rg_helper_init", uvm_component parent=null);
  super.new(name, parent);
endfunction : new

clifden_env top_env;

// Function: connect_phase
//
function void connect_phase (uvm_phase phase);
  super.connect_phase(phase);

  top_env = uvm_utils #(clifden_env)::find(uvm_top.top_levels[0]); //uvm_test_top;

  foreach (top_env.rfams_env_h[I]) begin : RFAMS_ENV_ITER

\`ifdef TB_TOP
    set_tc_ral(\`TC_RAL(I), I);
\`endif

\`ifdef TB_NUM_ADC
    foreach (\`ADC_ITER(I, J)) set_adc_ral(\`RFADC_RAL(I, J), I, J);
\`endif // TB_NUM_ADC

\`ifdef TB_NUM_DAC
    foreach (\`DAC_ITER(I, J)) set_dac_ral(\`RFDAC_RAL(I, J), I, J);
\`endif // TB_NUM_DAC

  end : RFAMS_ENV_ITER
endfunction : connect_phase

endclass : rfams_rg_helper_init

rfams_rg_helper_init __INIT__ = new;

\`undef ADC_ITER
\`undef DAC_ITER
\`undef RFADC_RAL
\`undef RFDAC_RAL
\`undef NUM_ADC_EQ_0
\`undef NUM_ADC_EQ_1
\`undef NUM_ADC_EQ_2
\`undef NUM_DAC_EQ_0
\`undef NUM_DAC_EQ_1
\`undef NUM_DAC_EQ_2
\`undef NUM_ADC_EQ_0__NUM_DAC_EQ_1
\`undef NUM_ADC_EQ_1__NUM_DAC_EQ_0
\`undef NUM_ADC_EQ_2__NUM_DAC_EQ_2
\`undef NUM_ADC_EQ_1__NUM_DAC_EQ_1
\`undef TB_ADC_ONLY
\`undef TB_DAC_ONLY
\`undef TB_TOP
\`undef num_adc_eq
\`undef num_dac_eq
\`undef num_adc_dac_eq

PACKAGE
}


# Function : samples_2matrix
#
function _samples_2matrix
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/samples_2matrix/\\e[1m&\\e[0m/g
                           s/samplefile/\\e[4m&\\e[0m/g
                           s/ (size|overlap)/ \\e[4m\1\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/printf "&"/e
                          '
usage: samples_2matrix  samplefile
                        [--window-size|--size|-s size]
                        [--window-overlap|--overlap overlap]
                        [--no-offset]
                        [--help|-h]

Options:

  --help|-h			      Print this help message
  --window-size|--size|-s size	      Window size in samples
  --window-overlap|--overlap overlap  Window overlap in samples
  --no-offset			      Do not offset samples

Arguments:

  samplefile			      File containing samples
USAGE

  exit ${1:-0}
  }

  local window_overlap=128 window_size=1024 window_id=0 offset=512

  #if ((!$#)); then
  #  usage 1
  #fi

  opt=$(getopt -a -oh,s:  -lhelp,window-size:,size:,no-offset -- "$@")
  if (($?)); then
    usage 1
  fi

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      --window-size|--size|-s)
          window_size=$2
          shift 2
          ;;

      --no-offset)
          offset=0
          shift
          ;;

      --) shift
          ;;

      *)
        samplefile=$1
        shift
        ;;
    esac
  done

  if [[ $samplefile ]]; then
    local samples=$(readlink -e $samplefile)
  fi

  cd $SUB_DIR
  rm -rf *

  truncate -s0 W.mat

  if [[ $samples ]]; then
    tail -n +$((offset +1)) $samples > left_trimmed
  elif [[ -p /dev/stdin ]]; then
    tail -n +$((offset +1)) /dev/stdin > left_trimmed
  else
    echo -e '\e[1;31m-E-\e[0m No sample to consume'
    exit 1
  fi

  while true; do
    local window=$(tail -n +$((1 + window_id*window_overlap)) left_trimmed | head -$window_size)

    if (($(echo "$window" | wc -l) < window_size)); then break; fi

    echo $window_id

    echo "$(paste W.mat <(echo "$window"))" > W.mat

    ((window_id++))
  done

  gvim W.mat
}


# Function: trim_samples
#
function _trim_samples
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/trim_samples/\\e[1m&\\e[0m/
                           s/\<samples|start|end/\\e[4m&\\e[0m/g
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/printf "&"/e
                          '
usage: trim_samples [--help|-h] [-s start] [-e end] samples 

Options

  --help|-h
    Print this help

  -s start
    Start trimming samples from start

  -e end
    End trimming samples from end

  samples
    Samples to trim

USAGE
  exit ${1:-0}
  }

  local file start=0 end=0

  if ((!$#)); then
    usage 1
  fi

  opt=$(getopt -a -oh,s:,e:  -lhelp,start:,end: -- "$@")
  if (($?)); then
    usage 1
  fi

  #echo "options: ($opt)"

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)  usage
                  ;;

      --start|-s)
        start=$2
        shift 2
        ;;

      --end|-e)
        end=$2
        shift 2
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option '$1'"
          usage 1
          ;;

      *)  file=$1
          shift
          ;;
    esac
  done

  #echo "file<$file> start<$start> end<$end>"
  if ((!end)); then
    if ((start)); then
      tail -n +$start $file
    fi
  elif ((start)); then
    head -n $end $file | tail -n +$start
  else
    head -n $end $file
  fi
}

# Function : trim
#
function _trim
{
  simenv trim_samples "$@"
}

# Function: plot_samples
#
function _plot_samples
{
  function usage
  {
    cat <<USAGE | sed -r  '
                           s/plot_samples/\\e[1m&\\e[0m/
                           s/\<samples/\\e[4m&\\e[0m/
                           s/(-) /\\e[1m\1\\e[0m /
                           s/ (style)/ \\e[4m\1\\e[0m/
                           s/--?([[:alnum:]_-])+/\\e[1m&\\e[0m/g
                           s/.*/printf "&"/e
                          '
usage: plot_samples [--help|-h] samples|- [--style|-s style]

Options

  -h, --help
    Display this help message

  -s, --style
    Plot style

  samples
    Samples to plot, if - then read from stdin
USAGE

  exit ${1:-0}
  }

  local style=lines

  if ((!$#)); then
    usage 1
  fi

  opt=$(getopt -a -oh,s:  -lhelp,style: -- "$@")
  if (($?)); then
    usage 1
  fi

  #echo "options: ($opt)"

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)  usage
                  ;;

      --style|-s)
        style=$2
        shift 2
        ;;

      --|-)
          shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option '$1'"
          usage 1
          ;;

      *)  file=$1
          shift
          ;;
    esac
  done

  if [[ $file ]]; then
    if [[ ! -f $file ]]; then
      echo -e '\e[1;31m-E-\e[0m Argument not a file' 
      exit 2
    fi
  elif [[ -p /dev/stdin ]]; then
    file=/dev/stdin
  else
    echo -e '\e[1;31m-E-\e[0m No sample to consume' 
    exit 3
  fi

  gnuplot -persist -e "plot '"$file"' with $style"
}

# Function : plot
#
function _plot
{
  simenv plot_samples "$@"
}

# Function: dump_fabric_data_in
#
function  _dump_fabric_data_in
{
  fsdb=$(readlink -e $1)
  testname=$(basename $fsdb .fsdb)

  cd $SUB_DIR
  rm -rf *

  for slice in $(seq 0 3); do
    echo -e "\e[34mExtracting Fabric data_in for slice $slice..\e[0m"

    fsdbreport $fsdb -nolog -of h 2>&1 >/dev/null \
    -exp "tb_top/GEN_ADC/INST[0]/adc/fabric_if[$slice]/fabric_clk==0 && tb_top/GEN_ADC/INST[0]/adc/fabric_if[$slice]/fifo_enable==1"  \
    -s   "tb_top/GEN_ADC/INST[0]/adc/fabric_if[$slice]/data_in[255:0]" -w 64 -o ${testname}__fabric_data_in_$slice.fsdb.samples

    tail -n +3 ${testname}__fabric_data_in_$slice.fsdb.samples  | \
    grep -o '\S\+$'                                             | \
    sed -r 's/..../& /g; s/ $//; s/\</0x/g; s#(\S+)#echo -n "$(if ((& >= 0x10000/2)); then echo $((&-0x10000)); else echo $((&)); fi) "; #ge'  | while read LINE; do
      sed 's/ /\n/g' <<<$LINE | tac
    done | sed -rn '
      1 {
        :next
        /^\s*0\s*$/ {
          n
          b next
        }
      }

      :next2
      /^[23][[:digit:]]{4}$/ {
        n
        b next2
      }

      : next3
      p
      n

      /^[123][[:digit:]]{4}$/ {
        h

        :filt_end
        n
        H
        /^[123][[:digit:]]{4}$/ {
          b filt_end
        }

        g
      }

      b next3

    ' > ${testname}__fabric_data_in_$slice.samples

    if [[ $(sort -u ${testname}__fabric_data_in_$slice.samples) == 0 ]]; then
      truncate -s0  ${testname}__fabric_data_in_$slice.samples
      echo -e "\e[34mFabric data_in for slice $slice is empty\e[0m"
    else
      echo -e "\e[34mGenerated ${testname}__fabric_data_in_$slice.samples\e[0m"
    fi

    echo

  done

  mv ${testname}__fabric_data_in_?.samples $PROJ_RUN
  rm ${testname}__fabric_data_in_?.fsdb.samples
} # dump_fabric_data_in


# Function : adc_decim_config
#
function _adc_decim_config
{
  local fsdb=$(readlink -e $1) adc=${2-0}

  cd $SUB_DIR
  rm -rf *

  #echo "\e[34mExtracting the decimation config\e[0m.." 1>&2

  fsdbreport $fsdb -of h  -o decim_config 2>&1 >/dev/null \
  -s "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Icontrol/I_slice_apb3_if_regs/decimation_config_decimation_config_ff" -a slice0 -w 1  \
     "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Icontrol/I_slice_apb3_if_regs/decimation_config_decimation_config_ff" -a slice1 -w 1  \
     "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Icontrol/I_slice_apb3_if_regs/decimation_config_decimation_config_ff" -a slice2 -w 1  \
     "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Icontrol/I_slice_apb3_if_regs/decimation_config_decimation_config_ff" -a slice3 -w 1

  tail -1 decim_config | sed 's/ /\n/g' | tail -n +2 | sort -u
} # adc_decim_config


# Function : process_slice_samples
#
function _process_slice_samples
{
  local in=$1 out=$2

    #tail -n +4 $in | cut -d' ' -f2- | xargs | sed 's/ /\n/g' | sed -r 's/^/0x/; s#(\S+)#echo -n "$(if ((& >= 0x10000/2)); then echo $((&-0x10000)); else echo $((&)); fi) "; #ge' > $out
    tail -n +4 $in | cut -d' ' -f2- | xargs | sed 's/ /\n/g' > $out
} # process_slice_samples


# Function: dump_adc_fe_dec_data
#
function _dump_adc_fe_dec_data
{
  if [[ -z $1 ]]; then
    echo -e "\e[1;31m-E-\e[0m Please provide a FSDB file"
    exit 1
  fi

  local fsdb=$(readlink -e $1) adc=${2-0}
  local testname=$(basename $fsdb .fsdb)

  cd $SUB_DIR
  rm -rf *

  local decim_config=$(simenv adc_decim_config $fsdb)

  if ((decim_config == 3)); then
    echo Extracting slice 01 samples - DUAL mode..
    fsdbreport $fsdb -of d  -o slice01 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/dec_data[0][0][15:0]"  -a sl_0_sb_0_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/dec_data[0][0][15:0]"  -a sl_1_sb_0_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/dec_data[1][0][15:0]"  -a sl_0_sb_1_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/dec_data[1][0][15:0]"  -a sl_1_sb_1_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/dec_data[0][1][15:0]"  -a sl_0_sb_0_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/dec_data[0][1][15:0]"  -a sl_1_sb_0_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/dec_data[1][1][15:0]"  -a sl_0_sb_1_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/dec_data[1][1][15:0]"  -a sl_1_sb_1_sa_1 -w 14

    echo Extracting slice 23 samples - DUAL mode..
    fsdbreport $fsdb -of d  -o slice23 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/dec_data[0][0][15:0]"  -a sl_0_sb_0_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/dec_data[0][0][15:0]"  -a sl_1_sb_0_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/dec_data[1][0][15:0]"  -a sl_0_sb_1_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/dec_data[1][0][15:0]"  -a sl_1_sb_1_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/dec_data[0][1][15:0]"  -a sl_0_sb_0_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/dec_data[0][1][15:0]"  -a sl_1_sb_0_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/dec_data[1][1][15:0]"  -a sl_0_sb_1_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/dec_data[1][1][15:0]"  -a sl_1_sb_1_sa_1 -w 14

    echo
    echo Processing slice 01 samples..
    simenv process_slice_samples slice01  $PROJ_RUN/${testname}__decoder_dual_slice01.samples
    echo Created $PROJ_RUN/${testname}__decoder_dual_slice01.samples

    echo
    echo Processing slice 23 samples..
    simenv process_slice_samples slice23  $PROJ_RUN/${testname}__decoder_dual_slice23.samples
    echo Created $PROJ_RUN/${testname}__decoder_dual_slice23.samples
    echo

  else
    echo Extracting slice 0 samples - QUAD mode..
    fsdbreport $fsdb -of d  -o decoder_quad_slice0 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/dec_data[0][0][15:0]"  -a sl_0_sb_0_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/dec_data[1][0][15:0]"  -a sl_0_sb_1_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/dec_data[0][1][15:0]"  -a sl_0_sb_0_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/dec_data[1][1][15:0]"  -a sl_0_sb_1_sa_1 -w 14

    echo Extracting slice 1 samples - QUAD mode..
    fsdbreport $fsdb -of d  -o decoder_quad_slice1 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/dec_data[0][0][15:0]"  -a sl_1_sb_0_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/dec_data[1][0][15:0]"  -a sl_1_sb_1_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/dec_data[0][1][15:0]"  -a sl_1_sb_0_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/dec_data[1][1][15:0]"  -a sl_1_sb_1_sa_1 -w 14

    echo Extracting slice 2 samples - QUAD mode..
    fsdbreport $fsdb -of d  -o decoder_quad_slice2 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/dec_data[0][0][15:0]"  -a sl_2_sb_0_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/dec_data[1][0][15:0]"  -a sl_2_sb_1_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/dec_data[0][1][15:0]"  -a sl_2_sb_0_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/dec_data[1][1][15:0]"  -a sl_2_sb_1_sa_1 -w 14

    echo Extracting slice 3 samples - QUAD mode..
    fsdbreport $fsdb -of d  -o decoder_quad_slice3 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/dec_data[0][0][15:0]"  -a sl_3_sb_0_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/dec_data[1][0][15:0]"  -a sl_3_sb_1_sa_0 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/dec_data[0][1][15:0]"  -a sl_3_sb_0_sa_1 -w 14 \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/dec_data[1][1][15:0]"  -a sl_3_sb_1_sa_1 -w 14


    for s in $(seq 0 3); do
      echo
      echo Processing slice $s samples..
      simenv process_slice_samples decoder_quad_slice$s  $PROJ_RUN/${testname}__decoder_quad_slice$s.samples
      echo Created $PROJ_RUN/${testname}__decoder_quad_slice$s.samples
    done
  fi
} # dump_adc_fe_dec_data


# Function: dump_adc_fe_ti_data
#
function _dump_adc_fe_ti_data
{
  if [[ -z $1 ]]; then
    echo -e "\e[1;31m-E-\e[0m Please provide a FSDB file"
    exit 1
  fi

  local fsdb=$(readlink -e $1) adc=${2-0}
  local testname=$(basename $fsdb .fsdb)

  cd $SUB_DIR
  rm -rf *

  local decim_config=$(simenv adc_decim_config $fsdb)

  if ((decim_config == 3)); then
    echo Extracting slice 01 samples - DUAL mode..
    fsdbreport $fsdb -of d  -o slice01 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/ti_data[0][0][13:0]"  -a sl_0_sb_0_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/ti_data[0][0][13:0]"  -a sl_1_sb_0_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/ti_data[1][0][13:0]"  -a sl_0_sb_1_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/ti_data[1][0][13:0]"  -a sl_1_sb_1_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/ti_data[0][1][13:0]"  -a sl_0_sb_0_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/ti_data[0][1][13:0]"  -a sl_1_sb_0_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/ti_data[1][1][13:0]"  -a sl_0_sb_1_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/ti_data[1][1][13:0]"  -a sl_1_sb_1_sa_1 -w 14

    echo Extracting slice 23 samples - DUAL mode..
    fsdbreport $fsdb -of d  -o slice23 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/ti_data[0][0][13:0]"  -a sl_0_sb_0_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/ti_data[0][0][13:0]"  -a sl_1_sb_0_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/ti_data[1][0][13:0]"  -a sl_0_sb_1_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/ti_data[1][0][13:0]"  -a sl_1_sb_1_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/ti_data[0][1][13:0]"  -a sl_0_sb_0_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/ti_data[0][1][13:0]"  -a sl_1_sb_0_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/ti_data[1][1][13:0]"  -a sl_0_sb_1_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/ti_data[1][1][13:0]"  -a sl_1_sb_1_sa_1 -w 14

    echo
    echo Processing slice 01 samples..
    simenv process_slice_samples slice01  $PROJ_RUN/${testname}__dcb_dual_slice01.samples
    echo Created $PROJ_RUN/${testname}__dcb_dual_slice01.samples

    echo
    echo Processing slice 23 samples..
    simenv process_slice_samples slice23  $PROJ_RUN/${testname}__dcb_dual_slice23.samples
    echo Created $PROJ_RUN/${testname}__dcb_dual_slice23.samples
    echo

  else
    echo Extracting slice 0 samples - QUAD mode..
    fsdbreport $fsdb -of d  -o dcb_quad_slice0 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/ti_data[0][0][13:0]"  -a sl_0_sb_0_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/ti_data[1][0][13:0]"  -a sl_0_sb_1_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/ti_data[0][1][13:0]"  -a sl_0_sb_0_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice0/Ifrontend/ti_data[1][1][13:0]"  -a sl_0_sb_1_sa_1 -w 14

    echo Extracting slice 1 samples - QUAD mode..
    fsdbreport $fsdb -of d  -o dcb_quad_slice1 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/ti_data[0][0][13:0]"  -a sl_1_sb_0_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/ti_data[1][0][13:0]"  -a sl_1_sb_1_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/ti_data[0][1][13:0]"  -a sl_1_sb_0_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[0]/Islice_pair01/Islice1/Ifrontend/ti_data[1][1][13:0]"  -a sl_1_sb_1_sa_1 -w 14

    echo Extracting slice 2 samples - QUAD mode..
    fsdbreport $fsdb -of d  -o dcb_quad_slice2 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/ti_data[0][0][13:0]"  -a sl_2_sb_0_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/ti_data[1][0][13:0]"  -a sl_2_sb_1_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/ti_data[0][1][13:0]"  -a sl_2_sb_0_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice0/Ifrontend/ti_data[1][1][13:0]"  -a sl_2_sb_1_sa_1 -w 14

    echo Extracting slice 3 samples - QUAD mode..
    fsdbreport $fsdb -of d  -o dcb_quad_slice3 2>&1 >/dev/null \
    -exp  "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Ianalog/clk_dig==0 && tb_top/GEN_ADC/INST[$adc]/adc/fabric_if[0]/fifo_enable==1"                             \
    -s    "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/ti_data[0][0][13:0]"  -a sl_3_sb_0_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/ti_data[1][0][13:0]"  -a sl_3_sb_1_sa_0 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/ti_data[0][1][13:0]"  -a sl_3_sb_0_sa_1 -w 14  \
          "tb_top/GEN_ADC/INST[$adc]/adc/adc_tc_core/Iatom/Idigital/Idigital/gen_pair[1]/Islice_pair01/Islice1/Ifrontend/ti_data[1][1][13:0]"  -a sl_3_sb_1_sa_1 -w 14


    for s in $(seq 0 3); do
      echo
      echo Processing slice $s samples..
      simenv process_slice_samples dcb_quad_slice$s  $PROJ_RUN/${testname}__dcb_quad_slice$s.samples
      echo Created $PROJ_RUN/${testname}__dcb_quad_slice$s.samples
    done
  fi
} # dump_adc_fe_dec_data

# Function: dump_adc_vins
#
function _dump_adc_vins
{
  if [[ -z $1 ]]; then
    echo -e "\e[1;31m-E-\e[0m Please provide a FSDB file"
    exit 1
  fi

  local fsdb=$(readlink -e $1) adc=${2-0}
  local testname=$(basename $fsdb .fsdb)

  cd $SUB_DIR
  rm -rf *

  local decim_config=$(simenv adc_decim_config $fsdb)

  echo Extrating..
  fsdbreport $fsdb  -o vins 2>&1 >/dev/null                   \
  -levelstrobe  "tb_top/proc_mod/sample_valid_0==1" -a valid  \
  -s  "tb_top/GEN_ADC/INST[0]/adc/vin0_n"           -a vin0_n \
      "tb_top/GEN_ADC/INST[0]/adc/vin0_p"           -a vin0_p \
      "tb_top/GEN_ADC/INST[0]/adc/vin1_n"           -a vin1_n \
      "tb_top/GEN_ADC/INST[0]/adc/vin1_p"           -a vin1_p \
      "tb_top/GEN_ADC/INST[0]/adc/vin2_n"           -a vin2_n \
      "tb_top/GEN_ADC/INST[0]/adc/vin2_p"           -a vin2_p \
      "tb_top/GEN_ADC/INST[0]/adc/vin3_n"           -a vin3_n \
      "tb_top/GEN_ADC/INST[0]/adc/vin3_p"           -a vin3_p

  echo Post-processing..
  data=$(tail -n +4 vins  | cut -d' ' -f2- | sed 's/\s\+/\t/g; s/m//g')

  echo "$data" | cut -f1 > ${testname}_vin0_n
  echo "$data" | cut -f2 > ${testname}_vin0_p
  echo "$data" | cut -f3 > ${testname}_vin1_n
  echo "$data" | cut -f4 > ${testname}_vin1_p
  echo "$data" | cut -f5 > ${testname}_vin2_n
  echo "$data" | cut -f6 > ${testname}_vin2_p
  echo "$data" | cut -f7 > ${testname}_vin3_n
  echo "$data" | cut -f8 > ${testname}_vin3_p

  readlink -e *_vin?_?
}

# Function: fft_log
#
#   Simulation need to be run with +showevent
#
function _fft_log
{
  function usage
  {
    echo "Usage: fft_log [options] <log>"
    echo
    echo "Options:"
    echo "  -h, --help		    Print this help, then exit"
    echo "  -d, --directory <dir>   Directory to store results"
    echo
    echo "Arguments:"
    echo "  log	    Log file"
    echo
    echo "Caveat:"
    echo "  Simulation must be run with +showevent"

    exit ${1:-0}
  }


  options=$(getopt -o h,d: --long help,directory: -n 'fft_log' -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $options

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -d|--directory)
	      directory=$2
	      shift 2
	      ;;

      --) shift
	      ;;

      *)  log=$1
	        shift
	        ;;
    esac
  done


  if [[ -z $log ]]; then
    echo -e "ERROR [FFT_LOG] Missing log file" 1>&2
    usage 1
  else
    local log=$(readlink -e $log)

    if [[ -z $log ]]; then
      echo -e "ERROR [FFT_LOG] Log file doesn't exist" 1>&2
      usage 1
    fi
  fi

  local crf_rundir=$(dirname $log | xargs dirname  | xargs dirname | xargs dirname | xargs basename)
  local   testname=$(dirname $log | xargs basename) # | sed 's/_iter[[:digit:]]+$//')

  if [[ -z $directory ]]; then
    export directory=$PWD

  elif [[ ! -d $directory ]]; then
    echo -e "ERROR [FFT_LOG] Directory $directory doesn't exist" 1>&2
    usage 1
  fi

  export csv=$directory/${crf_rundir}__${testname}__fft.csv

  #export minmax_csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__samples_min_max.csv

  adc_checker=$(grep -Em1 'm_adc_checker_t\s+adc_checker_t_e' $log | sed -r 's/.*\s(\w+)\s+$/\1/')

  if [[ $adc_checker != ADC_TONE_DETECTION ]]; then
    echo -e "WARNING [FFT_LOG] ADC checker is \e[1m$adc_checker\e[0m for \e[1m$testname\e[0m, quitting." 1>&2
    exit
  fi

  echo "INFO [FFT_LOG] Processing file $log .." 1>&2

  echo "sep=," > $csv
  echo "SLICE,WINDOW,STATUS,ENOB,SNR,SFDR,FINR,MODEL TONE COUNT (+/-),DESIGN TONE COUNT (+/-),DESIGN FUN (Hz),INPUT FUN (Hz),MODEL FREQ (Hz/Amp),DESIGN FREQS (#:+/- Hz/Amp)" >> $csv
  function parse
  {
    local data=$(< sed_data)
    truncate -s0 sed_data

     # echo "==============================================================================================================================================================" 1>&2
     # echo "$data" 1>&2
     # echo "==============================================================================================================================================================" 1>&2

    local slice_window=($(sed -rn 's/.+ ADC([[:digit:]]) Analysis Results for w#([[:digit:]]+)/\1 \2/p' <<<"$data"))
    local slice=${slice_window[0]} window=${slice_window[1]}

    local status=$(sed -rn 's/^UVM_ERROR @ .+/1/p' <<<"$data" | sort -u)
    status=$(if ((status)); then echo FAIL; else echo PASS; fi)

    local freq_count_model_design=($(sed -rn 's/.+ Number or tones detected for Model\s+([[:digit:]]+) and for Design\s+([[:digit:]]+)/\1 \2/p' <<<"$data"))
    local model_freq_count=$((freq_count_model_design[0])) design_freq_count=$((freq_count_model_design[1]))

    local fun_design=$(sed -rn 's/.+ fundamental frequency in Design found\(abs\) @ (\S+) Hz/\1/p' <<<"$data")
    local fun_input=$(sed -rn 's/.+ fundamental frequency of Input  found @ (\S+) Hz/\1/p' <<<"$data")

    local freq_model=$(sed -rn 's/.+ Freq Index\s+1: Model Freq: (\S+) Hz, Model Amplitude: (\S+)/\1\/\2/p' <<<"$data")

    #local freqs_design=($(sed -rn 's/.+ Tone Index\s+[[:digit:]]+, NO MATCH FOUND: Design Freq: ([[:digit:]]+\.[[:digit:]]+) Hz, Design Amplitude: (\S+)/\1\/\2/p' <<<"$data"))
    local freqs_design=($(sed -rn 's/.+ Ampl\[([[:digit:]]+)\]  is (-?[[:digit:]]+\.[[:digit:]]+) @ (-?[[:digit:]]+\.[[:digit:]]+)Hz/\1:\3\/\2/p' <<<"$data"))
    local freqs_design_str=$(echo ${freqs_design[*]} | sed -r 's/ /      /g')

    local sfdr=$(sed -rn 's/.+ ADC[[:digit:]] SFDR\s+(\S+)/\1/p' <<<"$data")
    local  snr=$(sed -rn 's/.+ ADC[[:digit:]] SNR\s+(\S+)/\1/p'  <<<"$data")
    local enob=$(sed -rn 's/.+ ADC[[:digit:]] ENOB\s+(\S+)/\1/p' <<<"$data")
    local finr=$(sed -rn 's/.+ ADC[[:digit:]] FINR\s+(\S+)/\1/p' <<<"$data")

    echo  "$slice,$window,$status,$enob,$snr,$sfdr,$finr,$model_freq_count,$design_freq_count,$fun_design,$fun_input,$freq_model,$freqs_design_str"
    #echo "==============================================================================================================================================================" 1>&2

  } >> $csv

  export -f parse

  pushd $SUB_DIR 2>&1 >/dev/null

  sed -rn '
    /event: analyze_signal_fft_start/ {
      : next
      n

      /event: analyze_signal_fft_start/ {
        g
        w sed_data
        s/.*/parse/e

        z; h;
        b next
      }

      /event: analyze_signal_end/ {
        g
        w sed_data
        s/.*/parse/e

        z
        h
        : next_analyze
        n
        /event: analyze_signal_fft_start/b next
        b next_analyze
      }

      H
      b next
    }

  ' $log

  popd 2>&1 >/dev/null

  # simenv fft_samples_min_max $(dirname $log)

  # echo "sep=," > $csv.merged
  # paste -d, <(tail -n +2 $csv | cut -d, -f1-7) <(tail -n +2 $minmax_csv | cut -d, -f3-4) <(tail -n +2 $csv | cut -d, -f8-13) >> $csv.merged
  # cp -f $csv.merged $csv
  # rm -f $csv.merged  $minmax_csv


  echo "INFO [FFT_LOG] Created $csv"  1>&2
}


# Function: cal_status_ra
#
function _cal_status_ra
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [CAL_STATUS_RA] Missing log file" 1>&2
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    local opath=$(readlink -f $2)

    if [[ $opath ]]; then
            local opath_dir=$(dirname $opath)
            local opath_base=$(basename $opath)

    else
      echo "ERROR [CAL_STATUS_RA] Directory path doesn't exist" 1>&2
      exit 1
    fi

    export csv=$(readlink -f $2)__ra_offset_gain.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__ra_offset_gain.csv
  fi

  echo "INFO [CAL_STATUS_RA] Processing file $1 .." 1>&2

  echo "sep=,"  > $csv
  echo "RESIDUE CODE,RESIDUE ERROR,TOLERANCE,CORRECTION VAL,ERROR VAL,CODE,STEP SIZE,PATH" >> $csv
  function parse
  {
    local data=$1

    # echo "data<$1>"
    local cal_status=($(sed -rn 's/.+ Residue-Code:\s*(\S+) \(\s*(\S+)\s*\), Tol\s*(\S+), Correction Val\s*([^,]+), Err Val\s*([^,]+), Code:\s*([^,]+), Step-Size:\s*(\S+) For (\S+)\s*/\1 \2 \3 \4 \5 \6 \7 \8/p' <<<"$data"))

    local   residue_code=${cal_status[0]}
    local  residue_error=${cal_status[1]}
    local      tolerance=${cal_status[2]}
    local correction_val=${cal_status[3]}
    local      error_val=${cal_status[4]}
    local           code=${cal_status[5]}
    local      step_size=${cal_status[6]}
    local           path=${cal_status[7]}

    #echo -e "--------------------------------"
    #for s in ${cal_status[*]}; do
    #  echo "<$s>"
    #done
    #echo -e "--------------------------------\n"
    echo "$residue_code,$residue_error,$tolerance,$correction_val,$error_val,$code,$step_size,$path"

  } >> $csv

  export -f parse

  sed -rn 's/^UVM_INFO @ .+ Correction Val.+ Err Val.+ Step-Size:.+/parse "&"/e' $log

  echo "INFO [CAL_STATUS_RA] Created $csv"  1>&2
  #echo $csv
}

# Function: cal_status_comp_offset
#
function _cal_status_comp_offset
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [CAL_STATUS_COMP_OFFSET] Missing log file"
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__comp_offset.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__comp_offset.csv
  fi

  echo "INFO [CAL_STATUS_COMP_OFFSET] Processing file $1 .." 1>&2

  echo "sep=," >$csv
  echo "RESIDUE CODE,RESIDUE ERROR,TOLERANCE,IDEAL,ACTUAL,INJECTED ERROR,COARSE CODE,FINE CODE,COARSE STEP,FINE STEP,PATH,CALIBRATION BYPASS" >>$csv
  function parse
  {
    local data=$1

    #echo "data<$1>"
    local cal_status_1=($(sed -rn 's/.+ Residue-Code:\s*(\S+) \(\s*(\S+)\s*\), Tol\s*(\S+), ideal =\s*([^,]+), actual =\s*([^,]+), inj_err =\s*([^,]+), coarse_code =\s*([^,]+), fine_code =\s*([^,]+), coarse_step =\s*(\S+) fine_step =\s*\S+ for \S+ Calibration bypass =\s*\S+\s*/\1 \2 \3 \4 \5 \6 \7 \8 \9/p' <<<"$data"))
    local cal_status_2=($(sed -rn 's/.+ Residue-Code:\s*\S+ \(\s*\S+\s*\), Tol\s*\S+, ideal =\s*[^,]+, actual =\s*[^,]+, inj_err =\s*[^,]+, coarse_code =\s*[^,]+, fine_code =\s*[^,]+, coarse_step =\s*\S+ fine_step =\s*(\S+) for (\S+) Calibration bypass =\s*(\S+)\s*/\1 \2 \3/p' <<<"$data"))

    #echo "cal_status_1=<${cal_status_1[*]}>"
    #echo "cal_status_2=<${cal_status_2[*]}>"
    local cal_status=(${cal_status_1[*]} ${cal_status_2[*]})

    local   residue_code=${cal_status[0]}
    local  residue_error=${cal_status[1]}
    local      tolerance=${cal_status[2]}
    local          ideal=${cal_status[3]}
    local         actual=${cal_status[4]}
    local injected_error=${cal_status[5]}
    local    coarse_code=${cal_status[6]}
    local      fine_code=${cal_status[7]}
    local    coarse_step=${cal_status[8]}
    local      fine_step=${cal_status[9]}
    local           path=${cal_status[10]}
    local     cal_bypass=${cal_status[11]}

    #echo -e "--------------------------------"
    #for s in ${cal_status[*]}; do
    #  echo "<$s>"
    #done
    #echo -e "--------------------------------\n"
    echo "$residue_code,$residue_error,$tolerance,$ideal,$actual,$injected_error,$coarse_code,$fine_code,$coarse_step,$fine_step,$path,$cal_bypass"

  } >> $csv

  export -f parse

  #cd $SUB_DIR

  sed -rn 's/^UVM_INFO @ .+ coarse_code = .+ coarse_step = .+/parse "&"/e' $log

  echo "INFO [CAL_STATUS_COMP_OFFSET] Created $csv"
  #echo $csv
}

# Function: cal_status_latch_offset
#
function _cal_status_latch_offset
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [CAL_STATUS_LATCH_OFFSET] Missing log file" 1>&2
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__latch_offset.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__latch_offset.csv
  fi

  echo "INFO [CAL_STATUS_LATCH_OFFSET] Processing file $1 .." 1>&2

  echo "sep=," >$csv
  echo "RESIDUE CODE,RESIDUE ERROR,TOLERANCE,IDEAL,ACTUAL,INJECTED ERROR,LATCH CODE,LATCH STEP,PATH,CALIBRATION BYPASS" >>$csv
  function parse
  {
    local data=$1

    #echo "data<$1>"
    local cal_status_1=($(sed -rn 's/.+ Residue-Code:\s*(\S+) \(\s*(\S+)\s*\), Tol\s*(\S+), ideal =\s*([^,]+), actual =\s*([^,]+), inj_err =\s*([^,]+), latch_code =\s*([^,]+), latch_step =\s*(\S+) for (\S+) Calibration bypass =\s*\S+\s*/\1 \2 \3 \4 \5 \6 \7 \8 \9/p' <<<"$data"))
    local cal_status_2=$(sed -rn 's/.+ Residue-Code:\s*\S+ \(\s*\S+\s*\), Tol\s*\S+, ideal =\s*[^,]+, actual =\s*[^,]+, inj_err =\s*[^,]+, latch_code =\s*[^,]+, latch_step =\s*\S+ for \S+ Calibration bypass =\s*(\S+)\s*/\1/p' <<<"$data")

    #echo "cal_status_1=<${cal_status_1[*]}>"
    #echo "cal_status_2=<$cal_status_2>"
    local cal_status=(${cal_status_1[*]} $cal_status_2)

    local   residue_code=${cal_status[0]}
    local  residue_error=${cal_status[1]}
    local      tolerance=${cal_status[2]}
    local          ideal=${cal_status[3]}
    local         actual=${cal_status[4]}
    local injected_error=${cal_status[5]}
    local     latch_code=${cal_status[6]}
    local     latch_step=${cal_status[7]}
    local           path=${cal_status[8]}
    local     cal_bypass=${cal_status[9]}

    #echo -e "--------------------------------"
    #for s in ${cal_status[*]}; do
    #  echo "<$s>"
    #done
    #echo -e "--------------------------------\n"
    echo "$residue_code,$residue_error,$tolerance,$ideal,$actual,$injected_error,$latch_code,$latch_step,$path,$cal_bypass"

  } >>$csv

  export -f parse

  #cd $SUB_DIR

  sed -rn 's/^UVM_INFO @ .+ latch_code = .+ latch_step = .+/parse "&"/e' $log

  echo "INFO [CAL_STATUS_LATCH_OFFSET] Created $csv" 1>&2
  #echo $csv
}

# Function : fft_samples_min_max
#
function _fft_samples_min_max
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [FFT_SAMPLES_MIN_MAX] Missing test directory" 1>&2
    exit 1
  fi

  if [[ ! -d $1 ]]; then
    echo -e "ERROR [FFT_SAMPLES_MIN_MAX] Non-existent test directory" 1>&2
    exit 1
  fi

  local testdir=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__samples_min_max.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$testdir)
    export csv=$PWD/${crf_rundir}__$(basename $testdir)__samples_min_max.csv
  fi

  #echo "testdir($testdir) csv($csv)"

  cd $testdir

  echo "INFO [FFT_SAMPLES_MIN_MAX] Extracting min and max sample values for $testdir .."

  echo "sep=,"  > $csv
  echo "SLICE,WINDOW,MIN SAMPLE,MAX SAMPLE"     >> $csv
  ls fanalyze_ADC*_window*.samples | while read sample_file; do
    #echo $sample_file

    local slice_window=($(sed -rn 's/fanalyze_ADC([[:digit:]]+)_.+_window([[:digit:]]+).samples/\1 \2/p' <<< $sample_file))
    local  slice=${slice_window[0]}
    local window=${slice_window[1]}

    #echo "Processing samples for slice $slice , window $window  .."
    local sorted_samples=$(sed -r 's/e-/*32768*10^-/; s/0\.00000000e\+00/0/; s/.*/printf "%.0f\n" $(bc -l <<<"&")/e' $sample_file | sort -nu)
    local min=$(head -1 <<< "$sorted_samples")
    local max=$(tail -1 <<< "$sorted_samples")


    echo -e "$slice\t$window\t$min\t$max" 1>&2
    echo -e "$slice\t$window\t$min\t$max"

  done  | sort  -k1,1n -k2,2n | sed 's/\t/,/g' >> $csv

  echo "INFO [FFT_SAMPLES_MIN_MAX] Created $csv" 1>&2
  #echo $csv
}

# Function: comp_offset_injected_errors
#
function _comp_offset_injected_errors
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [COMPARATOR_OFFSET_INJECTED_ERRORS] Missing log file" 1>&2
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__comp_offset_injected_errors.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__comp_offset_injected_errors.csv
  fi

  echo "INFO [COMPARATOR_OFFSET_INJECTED_ERRORS] Processing file $1 .." 1>&2

  echo "sep=," >$csv
  echo "SLICE,SUBADC,STAGE,INT ERROR NAME,INT ERROR VALUE,SCALING FACTOR,FLOAT ERROR NAME,FLOAT ERROR VALUE,PATH" >>$csv

  grep ' \[comparator_offset\]' $log | while read line; do
    local  slice=$(sed -rn 's/.* slice: ([^,]+),.*/\1/p' <<<$line)
    local   path=$(sed -rn 's/.* path: (\S+)/\1/p'        <<<$line)
    local subadc=$(cut -d. -f11 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')
    local  stage=$(cut -d. -f13 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')

    local int_error_name_val=($(sed -rn 's/.* (\w+_int\[[[:digit:]]+\]): ([^,]+),.*/\1 \2/p' <<<$line))
    local int_error_name=${int_error_name_val[0]}
    local int_error_val=${int_error_name_val[1]}

    local scaling_factor=$(sed -rn 's/.* comp_offset_scale: ([^,]+),.*/\1/p' <<<$line)

    local float_error_name_val=($(sed -rn 's/.* (\w+\[[[:digit:]]+\]): ([^,]+),.*/\1 \2/p' <<<$line))
    local float_error_name=${float_error_name_val[0]}
    local float_error_val=${float_error_name_val[1]}

    echo -e "$slice\t$subadc\t$stage\t$int_error_name\t$int_error_val\t$scaling_factor\t$float_error_name\t$float_error_val\t$path"

  done | sort -k1,1n -k2,2n -k3,3n | sed 's/\t/,/g' >> $csv

  echo "INFO [COMPARATOR_OFFSET_INJECTED_ERRORS] Created $csv" 1>&2
}

# Function: latch_offset_injected_errors
#
function _latch_offset_injected_errors
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [LATCH_OFFSET_INJECTED_ERRORS] Missing log file" 1>&2
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__latch_offset_injected_errors.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__latch_offset_injected_errors.csv
  fi

  echo "INFO [LATCH_OFFSET_INJECTED_ERRORS] Processing file $1 .." 1>&2

  echo "sep=," >$csv
  echo "SLICE,SUBADC,STAGE,INT ERROR NAME,INT ERROR VALUE,SCALING FACTOR,FLOAT ERROR NAME,FLOAT ERROR VALUE,PATH" >>$csv

  grep ' \[latch_offset\]' $log | while read line; do
    local  slice=$(sed -rn 's/.* slice: ([^,]+),.*/\1/p' <<<$line)
    local   path=$(sed -rn 's/.* path: (\S+)/\1/p'        <<<$line)
    local subadc=$(cut -d. -f11 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')
    local  stage=$(cut -d. -f13 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')

    local int_error_name_val=($(sed -rn 's/.* (\w+_int\[[[:digit:]]+\]): ([^,]+),.*/\1 \2/p' <<<$line))
    local int_error_name=${int_error_name_val[0]}
    local int_error_val=${int_error_name_val[1]}

    local scaling_factor=$(sed -rn 's/.* latch_offset_scale: ([^,]+),.*/\1/p' <<<$line)

    local float_error_name_val=($(sed -rn 's/.* (\w+\[[[:digit:]]+\]): ([^,]+),.*/\1 \2/p' <<<$line))
    local float_error_name=${float_error_name_val[0]}
    local float_error_val=${float_error_name_val[1]}

    echo -e "$slice\t$subadc\t$stage\t$int_error_name\t$int_error_val\t$scaling_factor\t$float_error_name\t$float_error_val\t$path"

  done | sort -k1,1n -k2,2n -k3,3n | sed 's/\t/,/g' >> $csv

  echo "INFO [LATCH_OFFSET_INJECTED_ERRORS] Created $csv" 1>&2
}

# Function: ra_offset_injected_errors
#
function _ra_offset_injected_errors
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [RA_OFFSET_INJECTED_ERRORS] Missing log file" 1>&2
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__ra_offset_injected_errors.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__ra_offset_injected_errors.csv
  fi

  echo "INFO [RA_OFFSET_INJECTED_ERRORS] Processing file $1 .." 1>&2

  echo "sep=," >$csv
  echo "SLICE,SUBADC,STAGE,OFFSET_ERR_INT,OFFSET_SCALE,OFFSET_ERR,PATH" >>$csv

  grep ' \[ra_offset\]' $log | while read line; do
    local  slice=$(sed -rn 's/.* slice: ([^,]+),.*/\1/p' <<<$line)
    local   path=$(sed -rn 's/.* path: (\S+)/\1/p'        <<<$line)
    local subadc=$(cut -d. -f11 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')
    local  stage=$(cut -d. -f13 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')

    local int_error_val=$(sed -rn 's/.* offset_err_int: ([^,]+),.*/\1/p' <<<$line)

    local scaling_factor=$(sed -rn 's/.* offset_scale: ([^,]+),.*/\1/p' <<<$line)

    local float_error_val=$(sed -rn 's/.* offset_err: ([^,]+),.*/\1/p' <<<$line)

    echo -e "$slice\t$subadc\t$stage\t$int_error_val\t$scaling_factor\t$float_error_val\t$path"

  done | sort -k1,1n -k2,2n -k3,3n | sed 's/\t/,/g' >> $csv

  echo "INFO [RA_OFFSET_INJECTED_ERRORS] Created $csv" 1>&2
}

# Function: ra_gain_injected_errors
#
function _ra_gain_injected_errors
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [RA_GAIN_INJECTED_ERRORS] Missing log file" 1>&2
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__ra_gain_injected_errors.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__ra_gain_injected_errors.csv
  fi

  echo "INFO [RA_GAIN_INJECTED_ERRORS] Processing file $1 .." 1>&2

  echo "sep=," >$csv
  echo "SLICE,SUBADC,STAGE,GAIN_ERR_INT (%),GAIN_SCALE,GAIN_ERR,PATH" >>$csv

  grep ' \[ra_gain\]' $log | while read line; do
    local  slice=$(sed -rn 's/.* slice: ([^,]+),.*/\1/p' <<<$line)
    local   path=$(sed -rn 's/.* path: (\S+)/\1/p'        <<<$line)
    local subadc=$(cut -d. -f11 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')
    local  stage=$(cut -d. -f13 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')

    local int_error_val=$(sed -rn 's/.* gain_err_int: ([^,]+),.*/\1/p' <<<$line)

    local scaling_factor=$(sed -rn 's/.* gain_scale: ([^,]+),.*/\1/p' <<<$line)

    local float_error_val=$(sed -rn 's/.* gain_err: ([^,]+),.*/\1/p' <<<$line)

    echo -e "$slice\t$subadc\t$stage\t$int_error_val\t$scaling_factor\t$float_error_val\t$path"

  done | sort -k1,1n -k2,2n -k3,3n | sed 's/\t/,/g' >> $csv

  echo "INFO [RA_GAIN_INJECTED_ERRORS] Created $csv" 1>&2
}

# Function: capacitor_code
#
function _capacitor_code
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [CAPACITOR_CODE] Missing log file" 1>&2
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__capacitor_code.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__capacitor_code.csv
  fi

  echo "INFO [CAPACITOR_CODE] Processing file $1 .." 1>&2

  echo "sep=," >$csv
  echo "PAIR,SLICE,SUBADC_TOP,SUBADC_DEC,ID,CAP_CAL_LUT_ST1,CAP_CAL_LUT_ST2,CAP_CAL_LUT_ST3,IM3_DITHER_LUT_COEFF,PATH" >>$csv

  grep ' \[capacitor_code\]' $log | while read line; do
    local       pair=$(sed -rn 's/.* pair: ([^,]+),.*/\1/p'      <<<$line)
    local      slice=$(sed -rn 's/.* slice: ([^,]+),.*/\1/p'      <<<$line)
    local subadc_top=$(sed -rn 's/.* subadc_top: ([^,]+),.*/\1/p' <<<$line)
    local subadc_dec=$(sed -rn 's/.* subadc_dec: ([^,]+),.*/\1/p' <<<$line)
    local         id=$(sed -rn 's/.* ID: ([^,]+),.*/\1/p'         <<<$line)

    local  cap_cal_lut_st1=$(sed -rn 's/.* cap_cal_lut_st1: ([^,]+),.*/\1/p' <<<$line)
    local  cap_cal_lut_st2=$(sed -rn 's/.* cap_cal_lut_st2: ([^,]+),.*/\1/p' <<<$line)
    local  cap_cal_lut_st3=$(sed -rn 's/.* cap_cal_lut_st3: ([^,]+),.*/\1/p' <<<$line)
    local  im3_dither_lut_coeff=$(sed -rn 's/.* im3_dither_lut_coeff: ([^,]+),.*/\1/p' <<<$line)

    local  path=$(sed -rn 's/.* path: (\S+)/\1/p'  <<<$line)

    echo -e "$pair\t$slice\t$subadc_top\t$subadc_dec\t$id\t$cap_cal_lut_st1\t$cap_cal_lut_st2\t$cap_cal_lut_st3\t$im3_dither_lut_coeff\t$path"

  done | sort -k1,1n -k2,2n -k3,3n -k4,4n -k5,5rn | sed 's/\t/,/g' >> $csv

  echo "INFO [CAPACITOR_CODE] Created $csv" 1>&2
}

# Function: capacitor_mismatch_injected_errors
#
function _capacitor_mismatch_injected_errors
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [CAPACITOR_MISMATCH_INJECTED_ERRORS] Missing log file" 1>&2
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__capacitor_mismatch_injected_errors.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__capacitor_mismatch_injected_errors.csv
  fi

  echo "INFO [CAPACITOR_MISMATCH_INJECTED_ERRORS] Processing file $1 .." 1>&2

  echo "sep=," >$csv
  echo "SLICE,SUBADC,STAGE,INT ERROR NAME,INT ERROR VALUE,SCALING FACTOR,FLOAT ERROR NAME,FLOAT ERROR VALUE,PATH" >>$csv

  grep ' \[capacitor_mismatch\]' $log | while read line; do
    local  slice=$(sed -rn 's/.* slice: ([^,]+),.*/\1/p' <<<$line)
    local   path=$(sed -rn 's/.* path: (\S+)/\1/p'        <<<$line)
    local subadc=$(cut -d. -f11 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')
    local  stage=$(cut -d. -f13 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')

    local int_error_name_val=($(sed -rn 's/.* (\w+(\[[[:digit:]]+\])?): ([^,]+), cap_mismatch_scale:.*/\1 \3/p' <<<$line))
    local int_error_name=${int_error_name_val[0]}
    local int_error_val=${int_error_name_val[1]}

    local scaling_factor=$(sed -rn 's/.* cap_mismatch_scale: ([^,]+),.*/\1/p' <<<$line)

    local float_error_name_val=($(sed -rn 's/.* (\w+(\[[[:digit:]]+\])?): ([^,]+), slice:.*/\1 \3/p' <<<$line))
    local float_error_name=${float_error_name_val[0]}
    local float_error_val=${float_error_name_val[1]}

    echo -e "$slice\t$subadc\t$stage\t$int_error_name\t$int_error_val\t$scaling_factor\t$float_error_name\t$float_error_val\t$path"

  done | sort -k1,1n -k2,2n -k3,3n | sed 's/\t/,/g' >> $csv

  echo "INFO [CAPACITOR_MISMATCH_INJECTED_ERRORS] Created $csv" 1>&2
}

# Function: im3_dither_capacitor_mismatch_injected_errors
#
function _im3_dither_capacitor_mismatch_injected_errors
{
  if [[ -z $1 ]]; then
    echo -e "ERROR [IM3_DITHER_CAPACITOR_MISMATCH_INJECTED_ERRORS] Missing log file" 1>&2
    exit 1
  fi

  local log=$(readlink -e $1)

  if [[ $2 ]]; then
    export csv=$PWD/$(dirname $2 | xargs basename)__im3_dither_capacitor_mismatch_injected_errors.csv
  else
    local crf_rundir=$(sed -rn 's#.+/([^/]+)/simulation/.+#\1#p' <<<$log)
    export csv=$PWD/${crf_rundir}__$(dirname $log | xargs basename)__im3_dither_capacitor_mismatch_injected_errors.csv
  fi

  echo "INFO [IM3_DITHER_CAPACITOR_MISMATCH_INJECTED_ERRORS] Processing file $1 .." 1>&2

  echo "sep=," >$csv
  echo "SLICE,SUBADC,STAGE,INT ERROR NAME,INT ERROR VALUE,SCALING FACTOR,FLOAT ERROR NAME,FLOAT ERROR VALUE,PATH" >>$csv

  grep ' \[im3_dither_capacitor_mismatch\]' $log | while read line; do
    local  slice=$(sed -rn 's/.* slice: ([^,]+),.*/\1/p' <<<$line)
    local   path=$(sed -rn 's/.* path: (\S+)/\1/p'        <<<$line)
    local subadc=$(cut -d. -f11 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')
    local  stage=$(cut -d. -f13 <<<$path | sed -rn 's/.+([[:digit:]])$/\1/p')

    local int_error_name_val=($(sed -rn 's/.* (\w+(\[[[:digit:]]+\])?): ([^,]+), cap_mismatch_scale:.*/\1 \3/p' <<<$line))
    local int_error_name=${int_error_name_val[0]}
    local int_error_val=${int_error_name_val[1]}

    local scaling_factor=$(sed -rn 's/.* cap_mismatch_scale: ([^,]+),.*/\1/p' <<<$line)

    local float_error_name_val=($(sed -rn 's/.* (\w+(\[[[:digit:]]+\])?): ([^,]+), slice:.*/\1 \3/p' <<<$line))
    local float_error_name=${float_error_name_val[0]}
    local float_error_val=${float_error_name_val[1]}

    echo -e "$slice\t$subadc\t$stage\t$int_error_name\t$int_error_val\t$scaling_factor\t$float_error_name\t$float_error_val\t$path"

  done | sort -k1,1n -k2,2n -k3,3n | sed 's/\t/,/g' >> $csv

  echo "INFO [IM3_DITHER_CAPACITOR_MISMATCH_INJECTED_ERRORS] Created $csv" 1>&2
}

# Function: fg_cal_passfail
#
function _fg_cal_passfail
{
  function usage
  {
    echo "Usage: fg_cal_passfail [<crf directory>]"
    echo
    echo "  <crf directory> is the directory containing the run.log files, default is the current directory"

    exit ${1:-0}
  }

  if (($# < 1)); then
    usage 1
  fi

  local path=${1:-$PWD}

  local rundir=$(readlink -e $path)

  if [[ ! -d $rundir ]]; then
    echo "ERROR [FG_CAL_PASSFAIL] CRF run directory '$rundir' doesn't exist"
    exit 1
  fi

  crfrundir=$(basename $rundir)
  # cd $rundir
  cd $SUB_DIR

  export csv=$rundir/${crfrundir}__fg_cal_passfail.csv

  echo "sep=," >$csv
  echo "ID,TEST,SEED,SLICE,FFT,CAL" >>$csv

  simenv file -d $rundir run.log | while read log; do
    echo "INFO [FG_CAL_PASSFAIL] Processing file $log .." 1>&2

    path=$(dirname $log)
    base=$(basename $path)
    tc=$(echo $base | sed -r 's/_iter[[:digit:]]+//')
    seed=$(grep -Po 'seed used: \K\d+' $log)

    mkdir $base
    pushd $base 2>&1 >/dev/null

    sed -rn '
      s/.+: (\w+):([[:digit:]]+)\s+DETECTED.*/echo \1 >> \2/e
      s/^UVM_ERROR @ .+adc_scbd_h\[([[:digit:]])\] .+/touch \1ERROR/e
      s/^UVM_ERROR @ [[:digit:]]+ ps: reporter \[RNM HELPER\] .+IRX01.I_ADC_Q.+/touch 0CALERROR/e
      s/^UVM_ERROR @ [[:digit:]]+ ps: reporter \[RNM HELPER\] .+IRX01.I_ADC_I.+/touch 1CALERROR/e
      s/^UVM_ERROR @ [[:digit:]]+ ps: reporter \[RNM HELPER\] .+IRX23.I_ADC_Q.+/touch 2CALERROR/e
      s/^UVM_ERROR @ [[:digit:]]+ ps: reporter \[RNM HELPER\] .+IRX23.I_ADC_I.+/touch 3CALERROR/e
    ' $log

    for slice in $(ls -d ?); do
      local status=$(   if [[ -f ${slice}ERROR    ]]; then echo FAIL; else echo PASS; fi)
      local calstatus=$(if [[ -f ${slice}CALERROR ]]; then echo FAIL; else echo PASS; fi)

      steps=$(cat <(cat $slice | nl -nln -s" " -w1 | sed -r 's/(\S+) (\S+)/\2 \1/') <(seq -f "- %.0f" 14) | sort -k2,2n -k1,1r | uniq -f1 | cut -d' ' -f1 | xargs | sed 's/ /,/g')

      echo ",$tc,$seed,$slice,$status,$calstatus,$steps"
    done

    popd 2>&1 >/dev/null

  done >> $csv
  #done | nl -nln -s, -w1 >> $csv


  echo "INFO [FG_CAL_PASSFAIL] Created $csv" 1>&2
}


# Function: fg_cal_run_csv
#
function _fg_cal_run_csv
{
  function usage
  {
    echo "Usage: fg_cal_run_csv [<crf directory>]"
    echo
    echo "  <crf directory> is the directory containing the run.log files, default is the current directory"

    exit ${1:-0}
  }

  if (($# < 1)); then
    usage 1
  fi

  local run_csv_dir=${1:-$PWD}

  local rundir=$(readlink -e $run_csv_dir)

  if [[ ! -d $rundir ]]; then
    echo "ERROR [FG_CAL_RUN_CSV] CRF run directory '$rundir' doesn't exist"
    exit 1
  fi

  echo -n "Generating the reg_field map.. "
  simenv reg_field_list > reg_field

  simenv file -d $rundir run.log | while read log; do
    echo "INFO [RUN_CSV] Processing $log .."

    simenv  fft_log                                       $log

    simenv  cal_status_ra                                 $log
    simenv  cal_status_comp_offset                        $log
    simenv  cal_status_latch_offset                       $log

    simenv  capacitor_code                                $log

    simenv  comp_offset_injected_errors                   $log
    simenv  latch_offset_injected_errors                  $log
    simenv  ra_offset_injected_errors                     $log
    simenv  ra_gain_injected_errors                       $log
    simenv  capacitor_mismatch_injected_errors            $log
    simenv  im3_dither_capacitor_mismatch_injected_errors $log

    simenv  log_regaccess_to_csv -regf reg_field	  $log

    echo
  done

  simenv fg_cal_passfail  $rundir
}

# Function: annotate_png
#
function _annotate_png
{
  function usage
  {
    echo "Usage: annotate_png [OPTIONS] [<png_files>]"
    echo
    echo "Options:"
    echo "  --help, -h			              Display this message and exit"
    echo "  --date, -d			              Date to annotate, YYYY-MM-DD"
    echo "  --samedir, --sd		            Store the annotated images in the same directory as the original images"
    echo "  --output-directory, -od	      Store the annotated images in this directory"
    echo "  --echo-name-only, --name -n,  Echo only the full file name of the annotated images"
    echo "  <png_files>			              PNG files to annotate, if not specified, stdin is used"

    exit ${1:-0}
  }

  opt=$(getopt -a -oh,d:,n  -lhelp,date:,sd,samedir,od:,output-directoty:,echo-name-only,name -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)
              usage
              ;;

      --date|-d)
              date=$2
              shift 2
              ;;

      --samedir|--sd)
            samedir=1
            ;;

      --output-directory|-od)
            output_dir=$(readlink -e $2)

            if [[ -d $output_dir ]]; then
              echo -e "\e[1;31m-E-\e[0m Can't locate output directory!"
              exit 1
            fi

            shift 2
            ;;

      --echo-name-only|--name|-n)
            echo_name_only=1
            shift
            ;;

      --|-)
          shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option '$1'"
          usage 1
          ;;

      *)  pngall[$((id++))]=$(readlink -e $1 2>/dev/null)
          shift
          ;;
    esac
  done


  if [[ -p /dev/stdin ]]; then
    for p in $(cat /dev/stdin); do
      pngall[$((id++))]=$p
    done
  fi

  for png in ${pngall[@]}; do
    local dir=$(dirname $png)
    local base=$(basename $png .png)
    local tdir=$(echo $dir | xargs basename)
    local tbase=$(echo  $tdir | sed -r 's/_iter[[:digit:]]+//')
    local titer=$(echo  $tdir | sed -rn 's/.*_iter([[:digit:]]+)/\1/p')
    local file=${tbase}_${titer:+$(echo ${titer}_)}$(echo $base | sed -r 's/fanalyze_//; s/\./_/; s/ADC/slice/')${date:+_$date}.png
    local vcl=$(simenv changelist verif | cut -f2)
    local rcl=$(simenv changelist rtl   | cut -f2)
    local slice_window=($(echo $base | grep -Po '(?:ADC|DAC)\K\d+|window\K\d+'))
    local fft_iter=$(echo $png | sed -rn 's/.*MHz_([[:digit:]]+)_window.*/\1/p')

    if [[ $output_dir ]]; then
      cd $output_dir
    elif ((samedir)); then
      cd $dir 
    fi

    if ((!echo_name_only)); then echo -n "[ANNOTATE_PNG] Generating "; fi
    echo $PWD/$file

    seed=$(grep -Po 'seed used: \K\d+|\+ntb_random_seed=\K\d+' $dir/run.log)

    convert -pointsize 19             \
            -font DejaVu-Sans-Mono    \
            -gravity NorthWest        \
            -fill magenta3            \
            -annotate +85+63   "$tbase${titer:+   #$titer}${fft_iter:+   #$fft_iter}"  \
            -pointsize 20                     \
            -fill Blue                        \
            -annotate +690+90  "SEED  $seed"  \
            -annotate +690+117 "SLICE  ${slice_window[0]}"  \
            -annotate +690+149 "WINDOW  ${slice_window[1]}" \
            -fill chocolate4                \
            -annotate +120+835 "VCL  $vcl"  \
            -annotate +405+835 "RCL  $rcl"  \
            $png  $file
  done
}

# Function: merge_png
#
function _merge_png
{
  opt=$(getopt -a -oh,d:,t:,o:  -lhelp,date:,tile:,echo-name-only -- "$@")
  if (($?)); then
    usage 1
  fi

  #echo "options: ($opt)"

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)  #usage
                  ;;

      -o) ofile=$2
          shift 2
          ;;

      --date|-d)  date=$2
                  shift 2
                  ;;

      --tile|-t)  tile=$2
                  shift 2
                  ;;

      --echo-name-only)
              echo_name_only=1
              shift
              ;;

      --|-)
          shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option '$1'"
          usage 1
          ;;

      *)  path[$((pathid++))]=$(readlink -e $1)
          shift
          ;;
    esac
  done

  set -- "${path[@]}"

  : date=${date:-$(date +'%Y%m%d')} tile=${tile:-2x}

  local file=$(if [[ -z $ofile ]]; then echo merge; else echo $(basename $ofile .png); fi)_$date.png

  if ((!echo_name_only)); then echo -n "[MERGE_PNG] Generatting "; fi
  echo $file

  montage -mode concatenate -tile $tile geometry '+0+50' $(ls -tr $(readlink -e $*)) $file
}

# Function: reg_field
#
function _reg_field
{
  function usage
  {
    echo "Usage: reg_field <scope> <regmodel>"
    echo
    echo "Arguments:"
    echo "  <scope>	scope (adc|dac|com)"
    echo "  <regmodel>	register model"

    exit ${1:-0}
  }

  if (($#<2)); then
    usage 1
  fi

  local scope=$1 rm=$2

  export scope

  cd $SUB_DIR

  function proc
  {
    if [[ -s field ]]; then
      cat reg field | paste -s
    fi

    if [[ $1 ]]; then
      echo -e "$scope\t$1" > reg
      rm -f field
    fi
  }

  export -f proc

  sed -rn '/extends\s+uvm_reg\>|\.configure\(this, [[:digit:]]/p' $rm | \
  sed -rn '
    s/.+_bank_([A-Z0-9_]+)\s+extends.*/proc \1/ep
    s/.*\.(\w+)\.configure\(this,\s+([[:digit:]]+),\s+([[:digit:]]+).*/echo  \1:\2:\3 >> field/e
    $ s/.*/proc ""/ep
  '
}

# Function: reg_field_list
#
function _reg_field_list
{
  local ral=$(ral_dir)

  echo Creating the reg field map... 1>&2

  (
  # **********************************************
  #                      ADC
  # **********************************************
  simenv reg_field  adc  $ral/adc/ral_rfadc_slice_apb3_if.sv
  simenv reg_field  adc  $ral/adc/ral_rfadc_subadc_if.sv

  # **********************************************
  #                      DAC
  # **********************************************
  simenv reg_field  dac $ral/dac/ral_rfdac_config.sv

  # **********************************************
  #                     RFCOM
  # **********************************************
  simenv reg_field  com $ral/com/ral_rfcom_main_apb_if.sv
  simenv reg_field  com $ral/com/ral_rfcom_pll_clk_apb_if.sv

  # **********************************************
  #                      TC
  # **********************************************
  simenv reg_field  tc $ral/tc/ral_rfams_tc_config.sv
  ) | grep -v '^\s*$'
}

# Function: log_regaccess_to_csv
#
function _log_regaccess_to_csv
{
  function usage
  {
    echo "Usage: log_regaccess_to_csv [options] [<log>...]"
    echo
    echo "Options:"
    echo
    echo "  -h, --help		      show this help message and exit"
    echo "  --regf  <reg_field> reg_field file"
    echo 
    echo "  <log>...		        log file(s), may also be provided via /dev/stdin"
    echo
    echo "Caveat:"
    echo "  Simulations must be run with at least UVM_MEDIUM"

    exit ${1:-0}
  }

  opt=$(getopt -a -oh  -lhelp,regf: --  "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)
          usage
          ;;

      --regf)
        reg_field=$(readlink -e $2)
        if [[ -z $reg_field ]]; then
          echo -e "\e[1;31m-E-\e[0m File '$2' not found"
          usage 1
        fi
  
        shift 2
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option '$1'"
          usage 1
          ;;

      *)  args[$((argsid++))]=$(readlink -e $1)
          shift
          ;;
    esac
  done

  if [[ -z $reg_field ]]; then
    if [[ ! -s reg_field ]]; then
      simenv reg_field_list > reg_field
    fi

    reg_field=reg_field
  fi

  export reg_field

  if ((!argsid)); then
    if [[ -p /dev/stdin ]]; then
      args=($(cat /dev/stdin)) 
    fi 
  fi

  if ((!${#args[@]})); then
    echo -e "\e[1;31m-E-\e[0m No log file(s) provided"
    usage 1
  fi


  function proc
  {
    local timestamp=$1 scope=$2 reg=$3 val=$4
    local old_scope=$scope

    if [[ $scope =~ (sub)?adc_reg_h([[:digit:]]) ]]; then
      #if [[ ${BASH_REMATCH[1]} ]]; then
      # local scope=subadc
      #else
        local scope=adc
      #fi

      local slice=${BASH_REMATCH[2]}
    else
      local scope=com
      local slice=-
    fi

    function fields
    {
      local scope=$1 reg=$2 val=$3

      for f in $(grep "^$scope\s$reg\>" $reg_field | cut -f3-); do
        local name=$(cut -d: -f1 <<<$f)
        local size=$(cut -d: -f2 <<<$f)
        local offset=$(cut -d: -f3 <<<$f)

        local fval=$((~(~0 << $size) & ($val >> $offset)))

        echo $name:$(printf "%0X" $fval)
      done  | paste -s
    }

    #echo -e "$timestamp\t$old_scope\t$scope\t$slice\t$reg\t$val"
    echo -e "$timestamp\t$scope\t$slice\t$reg\t$(printf "0x%0X" $val)\t$(fields $scope $reg $val)"
  }

  export -f proc

  for log in ${args[@]}; do
    echo Processing $log

    local testname=$(dirname $log | xargs basename)
    local crfdir=$(dirname $log | xargs dirname | xargs dirname | xargs dirname)
    local crfdirname=$(basename $crfdir)


    echo -e "sep=\t"  > $crfdir/${crfdirname}__${testname}__regaccess.csv
    grep ' \[RAL_WRITE' $log | sed -rn 's/^UVM_INFO @ ([[:digit:]]+) .+ adc_ral_h0\.(\w+)\.([A-Z0-9_]+): Write Data .+ = (0x[[:xdigit:]]+); .+/proc \1 \2 \3 \4/ep' >> $crfdir/${crfdirname}__${testname}__regaccess.csv

    fields_header=$(seq -f "FIELD %.0f" 1 $(($(tail -n +3 $crfdir/${crfdirname}__${testname}__regaccess.csv | sed -n 's/.*/echo "&" | wc -w/ep' | sort -nru | head -1) -5)) | paste -s)

    sed -i "2 i TIMESTAMP\tSCOPE\tSLICE\tREGISTER\tVALUE\t$fields_header" $crfdir/${crfdirname}__${testname}__regaccess.csv
  done

}

# Function: regaccess_to_csv
#
function _regaccess_to_csv
{
  function usage
  {
    echo "Usage: regaccess_to_csv [options] [<run directory>]"
    echo
    echo "Options:"
    echo "  -h, --help"
    echo "      --fail	      Only failed testcase are reported"
    echo
    echo "Arguments:"
    echo "  <run directory>   Directory to process, defaults to current directory"
    echo

    exit ${1:-0}
  }

  opt=$(getopt -a -o h -l help -n 'regaccess_to_csv' -- "$@")
  if [[ $? != 0 ]]; then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
          usage 1
          ;;
      
      *) dir=$1
         shift
         ;;
    esac
  done

  local dir=${dir:-$PWD}

  cd $SUB_DIR

  echo
  echo -n "Generating the reg_field map.. "
  simenv reg_field_list > reg_field

  echo Done.
  echo
  for log in $(simenv file -d $dir run.log); do
    echo Processing $log
    simenv log_regaccess_to_csv -regf reg_field $log
  done
}
 
# Function: regr_status
#
function _regr_status
{
  function usage
  {
    echo "Usage: regr_status [options] [<run directory>]"
    echo
    echo "Options:"
    echo "  -h, --help	  Show this help message and exit"
    echo "      --fail	  Only failed testcase are reported"
    echo
    echo "Arguments:"
    echo "  <run directory>  Directory to process, defaults to current directory"
    echo

    exit ${1:-0}
  }

  opt=$(getopt -a -o h -l help,fail -n regr_status -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      --fail)
        fail=1
        shift
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
          usage 1
          ;;

      *)  dir=$1
          shift
          ;;

    esac
  done

  if [[ -n $dir ]]; then
    if [[ ! -d $dir ]]; then
      echo -e "\e[1;31mNo such directory: $dir\e[0m"
      usage 1
    fi

    cd $dir
  fi

  simenv reg_field_list > reg_field

  simenv sim_cfg -s ${fail:+-fail}
  simenv runlog  ${fail:+-fail} | while read log; do
    simenv fft_log  $log
    simenv log_regaccess_to_csv -regf reg_field $log
    echo
  done
}


# Function: sim_cfg
#
function _sim_cfg
{
  function usage
  {
    echo "Usage: sim_cfg [options] [<run directory>]" 
    echo
    echo "Options:"
    echo "  -h, --help	     show this help message and exit"
    echo "  -m, --merge	     merge all cfg files in two sets"
    echo "  -s, --separator  Add separator lines for Microsoft CSV"
    echo "  -d, --directory  Destination directory for generated CSV files, defaults to current directory"
    echo "      --fail       Limit analysis to failed tests"
    echo
    echo "Arguments:"
    echo "  <run directory>  Directory to process, defaults to current directory"
    echo

    exit ${1:-0}
  }

  opt=$(getopt -a -oh,m,s,d: -lhelp,merge,separator,directory:,fail -n sim_cfg -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      -m|--merge)
        merge=1
        shift
        ;;

      -s|--separator)
        separator=1
        shift
        ;;

      -d|--directory)
        dest_dir=$2
        shift 2
        ;;
        
      --fail)
        fail=1
        shift
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
          usage 1
          ;;

      *)  rundir=$1
          shift
          ;;

    esac
  done

  if [[ -n $dest_dir ]]; then
    if [[ ! -d $dest_dir ]]; then
      echo -e "\e[1;31mNo such directory: $dest_dir\e[0m"
      usage 1
    fi
  fi

  dest_dir=$(readlink -e ${dest_dir:-$PWD})
  cd $dest_dir


  if [[ -n $rundir ]]; then
    if [[ ! -d $rundir ]]; then
      # If rundir is a file ending in run.log, use its directory
      if [[ -f $rundir && $rundir =~ .*run.log ]]; then
        rundir=$(dirname $rundir)
      else 
        echo -e "\e[1;31mNot a directory or a run.log: $rundir\e[0m"
        usage 1
      fi
    fi
  else
    rundir=$PWD
  fi


  #rm -f *__{slice,adc}_cfg.csv

  cfgs=$(
  if [[ -p /dev/stdin ]]; then
    cat /dev/stdin
  else
    simenv runlog $rundir ${fail:+--fail}
  
  fi | xargs -ILOG simenv test_sim_cfg LOG -d $dest_dir | simenv uniquify
  )

  slice_cfgs=($(echo "$cfgs" | grep slice_cfg))
    adc_cfgs=($(echo "$cfgs" | grep adc_cfg))


  for cfg in ${cfgs[*]}; do
    simenv transpose_csv -i $cfg
  done


  if ((merge)); then
    merge_slice_cfg=$(basename $PWD)__regr__slice_cfg.csv
      merge_adc_cfg=$(basename $PWD)__regr__adc_cfg.csv

    for cfg in ${cfgs[*]}; do
      simenv transpose_csv $cfg -o $cfg.tp
    done

    cat ${slice_cfgs[*]//.csv/.csv.tp} | sed -r '2,$ {/^testname/d}' > $merge_slice_cfg
    cat ${adc_cfgs[*]//.csv/.csv.tp}   | sed -r '2,$ {/^testname/d}' > $merge_adc_cfg

    simenv transpose_csv -i $merge_slice_cfg
    simenv transpose_csv -i $merge_adc_cfg

    if ((separator)); then
      sed -si '1i sep=,' $merge_slice_cfg $merge_adc_cfg
    fi

    rm ${cfgs[*]//.csv/.csv.tp}
  fi

  if ((separator)); then
    #sed -si '1i sep=,' ${cfgs[*]}
    simenv csv_separator add  ${cfgs[*]}
  fi

}


# Function: test_sim_cfg
#
function _test_sim_cfg
{
  function usage
  {
    echo "Usage: test_sim_cfg [options] <log>"
    echo
    echo "Options:"
    echo "  -h, --help"
    echo "  -d, --directory   Destination directory for the csv files, defaults to the current CRF subdirectory"
    echo "  -s, --separator   Add separator lines for Microsoft CSV"
    echo "  -x, --xlsx        Generate xlsx report"
    echo "  -q, --quiet       Suppress output"
    echo
    echo "Arguments:"
    echo "  <log>: log file to analyze"
    echo
    exit ${1:-0}
  }

  opt=$(getopt -a -oh,d:,s,q,x -lhelp,directory:,separator,xlsx,quiet -n test_sim_cfg -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      -d|--directory)
        directory=$2
        shift 2
        ;;

      -s|--separator)
        separator=1
        shift
        ;;

      -x|--xlsx)
        xlsx=1
        shift
        ;;

      -q|--quiet)
        quiet=1
        shift
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
          usage 1
          ;;
      
      *) log=$1
         shift
         ;;
    esac
  done

  if [[ -z $log ]]; then
    echo -e "\e[1;31mNo log file specified\e[0m"
    usage 1
  elif [[ ! -f $log ]]; then
    echo -e "\e[1;31mNo such file: $log\e[0m"
    usage 1
  fi


  export  log=$(readlink -e $log)
  export  testname=$(dirname $log | xargs basename | sed -r 's/_iter[[:digit:]]+$//')
  local   logdir=$(dirname $log)
  local	  logdirname=$(basename $logdir)
  local   crfdir=$(dirname $log | xargs dirname | xargs dirname | xargs dirname)
  export  crfdirname=$(basename $crfdir)
  export  status=$(ls $logdir/SIM_* | xargs basename | sed 's/SIM_//')

  if [[ -n $directory ]]; then
    if [[ ! -d $directory ]]; then
      echo -e "\e[1;31mNo such directory: $directory\e[0m"
      usage 1
    fi

    export  destdir=$directory
  else
    export  destdir=$crfdir
  fi 

  destdir=$(readlink -e $destdir)


  cd $SUB_DIR

  function test_cfg
  {
    local type=$1
    local cfg=$(echo "$2" | sed -r 's/'"'"'(b|d)//; s/'"'"'h/0x/; s/^\s+|\s+$//g; s/\s+/\t/g; s/^(\w+)\s.*\s(\S+$)/\1=\2/')

    eval "$cfg"

    csv=$destdir/${crfdirname}__${testname}__$type.csv
    testname=$(< testname)
    seed=$(< seed)

    (
      eval "$(echo -e "testname=$testname\nseed=$seed\nstatus=$status\n$cfg" | sed -r 's/^/echo /; s/(\w+)=.+/\1/')"  | paste -s | sed 's/\s/,/g'
      eval "$(echo -e "testname=$testname\nseed=$seed\nstatus=$status\n$cfg" | sed -r 's/^/echo /; s/(\w+)=.+/$\1/')" | paste -s | sed 's/\s/,/g'

    ) >> $csv

    echo $csv >> csvs
  }

  export -f test_cfg

  sed -rn '
    s/.*ntb_random_seed=([[:digit:]]+).*/echo "\1" > seed/e
    s/.*automatic random seed used: ([[:digit:]]+).*/echo "\1" > seed/e
    s/.*\sRunning\stest\s(\w+).*/echo "\1" > testname/e

    /^rfams_cfg_h0/ {
      :next_cfg
      n
      /^ {6}adc_slice_cfg_h/ {
        n

        /^ {8}\[/ {
          n
          h

          :next
          n
          /^ {2,8}[^ ]/ {
            x
            s/.*/test_cfg slice_cfg "&"/e
            g

            /\[/ {
              n
              h
              b next
            }

            b fabric_cfg
          }

          H
          b next
        }
      }

      : fabric_cfg
      /^ {6}fabric_cfg_h/ {
        n

        /^ {8}\[/ {
          n
          h

          : fabric_next
          n
          /^ {2,8}[^ ]/ {
            x
            s/.*/test_cfg fabric_cfg "&"/e
            g

            /\[/ {
              n
              h
              b fabric_next
            }

            b analog_cfg
          }

          H
          b fabric_next
        }
      }
      
      : analog_cfg
      /^ {6}analog_cfg_h/ {
        n
	
        /^ {8}\[/ {
          n
          h
          
          : analog_next
          n
          /^ {2,8}[^ ]/ {
            x
            s/.*/test_cfg analog_cfg "&"/e
            g
            
            /\[/ {
              n
              h
              b analog_next
            }
            
            b adc_cfg
          }
          
          H
          b analog_next
        }
      }

      : adc_cfg
      /^ {6}id\>/ {
        h
  
        : id_next
        n
  
        /^ {6}initial/ {
          : initial_next
          
          n; n; n; n
          
          b id_next
        }
  
        /^-{10}/ {
          g
          s/.*/test_cfg adc_cfg "&"/e
          q
        }
  
        /^ {6}\w/ H
        b id_next
      }

      b next_cfg
    }

  ' $log


  if [[ ! -f csvs ]]; then
    echo -e "\e[1;31m-E-\e[0m No csvs found, that's probably due to the absence of config data in \e[1;23m$logdirname/run.log\e[0m" 1>&2
    nocsvs=1
  else
    simenv uniquify -i csvs | xargs sed -i '2,$ {/^testname/d}'
  fi

  if ((!quiet)); then
    if ((!nocsvs)); then
      cat csvs
    fi
  fi

  if ((xlsx)); then
    if ((!nocsvs)); then
      simenv csv_2xls -d $destdir $(< csvs)
    fi
  fi

  if ((separator)); then
    if ((!nocsvs)); then
      #sed -si '1i sep=,' $(< csvs)
      simenv csv_separator add	$(< csvs)
    fi
  fi

}

# Function: regr_passfail
#
function _regr_passfail
{
  function usage
  {
    echo "Usage: regr_passfail [options] [run directory]"
    echo
    echo "Options:"
    echo "  -h, --help		  Show this help message and exit"
    echo "  -s, --separator	  Add a separator to the CSV file"
    echo "  -o, --output <csv>	  Output CSV file,  defaults passfail_<yyyy><mm><dd>_<hh><mm><ss>.csv"
    echo "  -x, --xls    <xls>	  Output XLSX file, defaults passfail_<yyyy><mm><dd>_<hh><mm><ss>.xlsx"
    echo "  -q, --quiet		  Suppress output"
    echo
    echo "Arguments:"
    echo "   <run directory>	  Directory to process, defaults to current directory."

    exit ${1:-0}
  }

  opts=$(getopt -oh,o:,s,q -l help,output:,separator,quiet -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opts

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -s|--separator)
	      separator=1
	      shift
	      ;;

      -o|--output)
	      csv=$2
	      shift 2
	      ;;

      -x|--xls)
	      xls=$2
	      shift 2
	      ;;

      -q|--quiet)
	      quiet=1
	      shift
	      ;;

      --) shift
	        ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option: $1" 1>&2
	        usage 1
	        ;;

      *) rundir=$1
	 shift
	;;
    esac
  done

  if [[ -n $csv ]]; then
    csv=$(reallink -f $csv)
  fi

  default_csv=passfail_$(date +%Y%m%d_%H%M%S).csv
  output_csv=$(readlink  -f ${csv:-$default_csv})

  if [[ -n $rundir ]]; then
    if [[ ! -d $rundir ]]; then
      echo -e "\e[1;31m-E-\e[0m $rundir does not exist" 1>&2
      usage 1
    fi

    cd $rundir 
  fi

  for log in $(simenv runlog); do
    if ((!quiet)); then
      echo "Processing $log" 1>&2
    fi

    testname=$(simenv testname $log) 
    seed=$(simenv testseed $log)
    status=$(simenv teststatus $log)
    iter=$(basename $(dirname $log) | sed -rn 's/.*_iter([[:digit:]]+)/\1/p')
    
    if [[ $status == FAIL ]]; then
      msg=$(simenv testerrors $log | head -1 | sed 's/ /____space____/g')
    else
      msg="____empty____"
    fi

    echo $testname $seed "\"$iter\"" $status "\"$msg\"" $log
  done | sed -r 's/ /,/g; s/____space____/ /g; s/____empty____//g' > $output_csv	

  sed -i '1i testname,seed,iter,status,1st error,log' $output_csv

  if ((separator)); then
    simenv csv_separator add $output_csv
  fi

  simenv csv_2xls $output_csv
}

# Function: testname
#
function _testname
{
  function usage
  {
    echo "Usage: testname [options] <log>"
    echo
    echo "Options:"
    echo "  -h, --help    show this help message and exit"
    echo
    echo "Arguments:"
    echo "   <log>	  log file"

    exit ${1:-0}
  }

  opts=$(getopt -o h -l help -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opts

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option: $1" 1>&2
	      usage 1
	      ;;

      *)  log=$1
	        shift
	        ;;

    esac
  done

  if [[ -n $log ]]; then
    if [[ ! -f $log ]]; then
      echo -e "\e[1;31m-E-\e[0m $log does not exist" 1>&2
      usage 1
    fi
  else
    echo -e "\e[1;31m-E-\e[0m No log file specified" 1>&2
    usage 1
  fi


  grep -Pom1 'Running test \K\w+' $log
}

# Function: testiter
#
function _testiter
{
  function usage
  {
    echo "Usage: testiter [options] <log>"
    echo
    echo "Options:"
    echo "  -h, --help    show this help message and exit"
    echo
    echo "Arguments:"
    echo "   <log>	  log file"

    exit ${1:-0}
  }

  opts=$(getopt -o h -l help -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opts

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option: $1" 1>&2
	      usage 1
	      ;;

      *)  log=$1
	        shift
	        ;;

    esac
  done

  if [[ -n $log ]]; then
    if [[ ! -f $log ]]; then
      echo -e "\e[1;31m-E-\e[0m $log does not exist" 1>&2
      usage 1
    fi
  else
    echo -e "\e[1;31m-E-\e[0m No log file specified" 1>&2
    usage 1
  fi

  grep -A2 'RUN SCRIPT' $log | tail -1 | grep -Po '_iter\K\d+$'
}


# Function: testseed
#
function _testseed
{
  function usage
  {
    echo "Usage: testseed [options] [<log>...]"	  
    echo
    echo "Options:"
    echo "  -h, --help	    Show this help message and exit"
    echo "  -n, --name	    Display test name(s)"
    echo "  -p, --path	    Display path(s) to log files"
    echo
    echo "Arguments:"
    echo "   <log>...	  Log files, may be provided from standard input"

    exit ${1:-0}
  }

  opts=$(getopt -o h,n,p -l help,name,path -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opts

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -n|--name)
	      name=1
	      shift
	      ;;

      -p|--path)
	      path=1
	      shift
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option: $1" 1>&2
	      usage 1
	      ;;

      *)  logs[$((logid++))]=$1
	        shift
	        ;;
    esac
  done

  if [[ -p /dev/stdin ]]; then
    logs+=($(cat))
  fi

  if [[ ${#logs[@]} -eq 0 ]]; then
    echo -e "\e[1;31m-E-\e[0m No log file specified" 1>&2
    usage 1
  fi

  for log in "${logs[@]}"; do
    seed=$(grep -Po 'automatic random seed used: \K[[:digit:]]+|ntb_random_seed=\K[[:digit:]]+' $log)

    if ((name)); then
      testn=$(simenv testname $log)
    fi

    echo -e "${testn:+$testn\t}$seed${path:+\t$log}"
  done
}


# Function: teststatus
#
function _teststatus
{
  function usage
  {
    echo "Usage: teststatus [options] [<log>...]"
    echo
    echo "Options:"
    echo "  -h, --help	    Show this help message and exit"
    echo "  -v, --verbose   Display test name(s) & seed(s)"
    echo
    echo "Arguments:"
    echo "   <log>...	  Log files, may be provided from standard input"

    exit ${1:-0}
  }

  opts=$(getopt -o h,v -l help,verbose -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opts

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -v|--verbose)
	      verbose=1
	      shift
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option: $1" 1>&2
	      usage 1
	      ;;

      *)  logs[$((logid++))]=$1
	        shift
	        ;;
    esac
  done

  if [[ -p /dev/stdin ]]; then
    logs+=($(cat))
  fi

  if [[ ${#logs[@]} -eq 0 ]]; then
    echo -e "\e[1;31m-E-\e[0m No log file specified" 1>&2
    usage 1
  fi


  for log in "${logs[@]}"; do
    status=$(ls $(dirname $log)/SIM_* | sed -r 's/.+SIM_//')

    if ((verbose)); then
      name=$(simenv testname $log)
      seed=$(simenv testseed $log)
    fi

    echo -e "${name:+$name\t}${seed:+$seed\t}$status"
  done
}


# Function: testcrfdir
#
function _testcrfdir
{
  function usage
  {
    echo "Usage: testcrfdir [options] <log>"
    echo
    echo "Options:"
    echo "  -h, --help	    show this help message and exit"
    echo "  -a, --absolute  absolute path to crf directory"
    echo
    echo "Arguments:"
    echo "   <log>	  log file"

    exit ${1:-0}
  }

  opts=$(getopt -o h,a -l help,absolute -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opts

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -a|--absolute)
	      absolute=1
	      shift
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option: $1" 1>&2
	      usage 1
	      ;;

      *)  log=$1
	        shift
	        ;;
    esac
  done

  if [[ -n $log ]]; then
    if [[ ! -f $log ]]; then
      echo -e "\e[1;31m-E-\e[0m $log does not exist" 1>&2
      usage 1
    fi

    log=$(readlink -f $log)
  else
    echo -e "\e[1;31m-E-\e[0m No log file specified" 1>&2
    usage 1
  fi

  log=$(grep -A2 'RUN SCRIPT GENERATED BY CRF' $log | tail -1)

  cdir=$(dirname $log)
  while [[ ! -s $cdir/crf.log ]]; do
    cdir=$(dirname $cdir)

    if [[ $(basename $cdir) == CRF ]]; then
      echo -e "\e[1;31m-E-\e[0m crf.log not found" 1>&2 
      usage 2
    fi
  done

  if (( absolute )); then
    echo $cdir
  else
    basename $cdir
  fi
}

# Function: testcard
#
#
function _testcard
{
  function usage {
    echo -e "\e[1mUsage:\e[0m testcard [options] [<directory>...] [<log>...]"

    echo
    echo -e "\e[1mDescription:\e[0m"
    echo "  Generate the Test card CSV file for all the specified run.log files or run.log found in the specified directories."

    echo
    echo -e "\e[1mOptions:\e[0m"
    echo "  --help, -h        Display this help message"
    echo "  --quiet, -q       Suppress output to stdout"

    echo
    echo -e "\e[1mArguments\e[0m"
    echo "  <directory>...    Optional positional directory arguments to specify the directories to work on."
    echo "                    If not specified, and no run.log is provided either, the current directory is used."
    echo "                    May also be provided from stdin."
    
    echo
    echo "  <log>...          Optional positional log arguments to specify the log files to work on."
    echo "                    May also be provided from stdin."
    echo


    exit ${1:-0}
  }


  opt=$(getopt -a -oh,q -lhelp,quiet -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      -q|--quiet)
        quiet=1
        shift
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
          ;;

      *)  posarg[$((posargs_id++))]=$1 
          shift
          ;;

      esac
  done
   
  if [[ -p /dev/stdin ]]; then
    posarg+=($(cat))
  fi

  logs=($(for item in "${posarg[@]}"; do
    if [[ -f $item ]]; then
      if [[ $item =~ .*run.log$ ]]; then
        if [[ ! -f $item ]]; then
          echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m does not exist"
          continue
        fi

        echo $item
      else
        echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m is not a run.log" 
        continue
      fi
    else
      # Should be a directory
      if [[ ! -d $item ]]; then
        echo -e "\e[1;31m-E-\e[0m Directory or File \e[1m$item\e[0m does not exist" 1>&2
        continue
      else
        simenv log $item
      fi
    fi

  done | simenv uniquify))

  if ((!${#logs[@]})); then
    logs=($(simenv log))
  fi


  for log in "${logs[@]}"; do
    rundir=$(dirname $log)

    if ((!quiet)); then
      echo "Processing $rundir" 1>&2
    fi

    pushd $rundir > /dev/null

    (
      echo testname,$(simenv testname $log)
      echo seed,$(simenv testseed $log)
      echo iter,$(simenv testiter $log)
      echo log,$log
      if [[ -f $testname.fsdb ]]; then
        echo fsdb,$PWD/$testname.fsdb
      fi

      id=1
      for f in $(ls -d *.dbg 2>/dev/null); do
        echo dbg $id,$PWD/$f
        ((id++))
      done
    ) > $rundir/testcard.csv

    popd > /dev/null
  done
}


# Function: fail_pattern
#
function _fail_pattern
{
  grep fail_pattern $PROJ_INI | cut -d' ' -f3- | sed -r 's/,/|/g; s/\[|\]/\\&/g'
}

# Function: testerrors
#
function _testerrors
{
  function usage
  {
    echo "Usage: testerrors [options] [<log>...]"
    echo
    echo "Options:"
    echo "  -h, --help		  Show this help message and exit"
    echo "  -c, --count <count>	  Display only the first <count> errors"
    echo "  -H			  Show matching file name, like grep -H"
    echo "  -F			  Show matching file name"
    echo
    echo "Arguments:"
    echo "   <log>...		  Log files, may be provided from standard input"

    exit ${1:-0}
  }

  opts=$(getopt -o h,c:,H,F -l help,count: -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opts

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -c|--count)
	      count=$2
	      shift 2
	
	      if [[ ! $count =~ ^[0-9]+$ ]]; then
	        echo -e "\e[1;31m-E-\e[0m $count is not a number" 1>&2
	        usage 2
	      fi
	      ;;

      -H)
	      show_file=1
	      shift
	      ;;

      -F)
	      show_file=1
	      just_file=1
	      shift
	      ;;

      --) shift
	        ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option: $1" 1>&2
	        usage 3
	        ;;

      *)  logs[$((logid++))]=$1
	        shift
	        ;;

    esac
  done

  if [[ -p /dev/stdin ]]; then
    logs+=($(cat))
  fi

  if [[ ${#logs[@]} -eq 0 ]]; then
    echo -e "\e[1;31m-E-\e[0m No log file specified" 1>&2
    usage 4
  fi

  fail_pattern=$(simenv fail_pattern)
  fail_pattern+="|TERM_(RUN|MEM)LIMIT: job killed after reaching LSF (run time|memory usage) limit"

  for log in "${logs[@]}"; do
    grep -E ${show_file:+-H} "$fail_pattern" $log | if ((count)); then
      head -n $count  
    else
      if ((just_file)); then
	      cut -d: -f1 | sort -u
      else
	      cat
      fi
    fi
  done
}


# Function: transpose_csv
#
function _transpose_csv
{
  function usage
  {
    (
    echo "Usage: transpose_csv [options] [<csv>]"
    echo
    echo "Options:"
    echo "  -h, --help            show this help message and exit"
    echo "  -i, --inplace         overwrite the input file"
    echo "  -o, --output <file>   specify the output file"
    echo
    echo "Arguments:"
    echo "   <csv>: csv file to transpose, defaults to stdin"
    echo "          If both stdin and <csv> are provided, stdin is used"
    echo
    echo "  <file>: output file"
    echo
    echo "Description:"
    echo "  Transpose a csv file"
    echo

    ) | sed -r '
	  s/transpose_csv/\\e[1m&\\e[0m/
	  s/--?\w+/\\e[1m&\\e[0m/g
	  s/<\w+>/\\e[1m&\\e[0m/
	  s/.*/echo -e "&"/e
        ' 

    exit ${1:-0}

  }

  opt=$(getopt -a -oh,i,o: -l help,inplace,output: -n transpose_csv -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -i|--inplace)
	      inplace=1
	      shift
	      ;;

      -o|--output)
        output=$(readlink -f $2)
        if [[ -z $output ]]; then
          echo -e "\e[1;31m-E-\e[0m Path leading to output file have non-existing directory component(s)" 1>&2
          usage 1
        fi

	      shift 2
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
	      usage 1
	      ;;

      *)  file=$1
	        csv=$(readlink -e $file)
	        shift
	        ;;
    esac
  done

  if [[ -p /dev/stdin ]]; then
    stdin=1
  else
    if [[ -z $csv ]]; then
      echo -e "\e[1;31mNo such file: $file\e[0m"
      usage 1
    fi
  fi

  if ((inplace)) && [[ -n $output ]]; then
    echo -e "\e[1;31m-i and -o are mutually exclusive\e[0m"
    usage 1
  fi

  cd $SUB_DIR

  if ((stdin)); then
    cat > stdin_csv
  fi

  num_col=$(head -1 $(if ((stdin)); then echo stdin_csv; else echo $csv; fi) | tr ',' '\n' | wc -l)

  if ((stdin)); then
    cp stdin_csv csv.bak
  else
    cp $csv csv.bak
  fi

  for ((i=1; i <= $num_col; i++)); do
    cut -d, -f$i csv.bak | paste -s | tr '\t' ','
  done | if ((inplace && !stdin)); then
    cat > $csv
  elif [[ -n $output ]]; then
    cat > $output
  else
    cat
  fi
}

# Function: uniquify
#
# It is not using sort -u, nor uniq
#
function _uniquify
{
  function usage
  {
    echo "Usage: uniquify [options] [<file>]"
    echo
    echo "Options:"
    echo "  -h, --help            show this help message and exit"
    echo "  -i, --inplace         overwrite the input file"
    echo "  -q, --quiet           suppress output"
    echo
    echo "Arguments:"
    echo "  <file>: file to uniquify, defaults to stdin"
    exit ${1:-0}
  }


  opt=$(getopt -a -oh,i,q -lhelp,inplace,quiet -n uniquify -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -i|--inplace)
	      inplace=1
	      shift
	      ;;

      -q|--quiet)
	      quiet=1
	      shift
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
	      usage 1
	      ;;

      *)  file=$1
	      shift
	      ;;

    esac
  done

  
  if [[ -n $file ]]; then
    if [[ ! -f $file ]]; then
      echo -e "\e[1;31m-E-\e[0m No such file: \e[1m$file\e[0m"
      usage 1
    fi

    file=$(readlink -e $file)
  else
    file=/dev/stdin
  fi

  cd $SUB_DIR

  cp $file file.bak

  declare -A seen

  while read line; do
    # check if we've seen this line before
    if [[ ! ${seen[$line]+_} ]]; then
      seen[$line]=1

      echo $line
    fi
  done < file.bak | if ((inplace)); then
    cat | tee $file
  else
    cat
  fi | if ((!quiet)); then
    cat
  fi
}


# Function: move_fail_left
#
function _move_fail_left
{
  function usage
  {
    echo "Usage: move_fail_up [options] [<csv>]"
    echo
    echo "Options:"
    echo "  -h, --help            show this help message and exit"
    echo "  -i, --inplace         overwrite the input file"
    echo "  -q, --quiet           suppress output"
    echo
    echo "Arguments:"
    echo "  <csv>: file to process, defaults to stdin"
    exit ${1:-0}
  }

  opt=$(getopt -a -oh,i,q -lhelp,inplace,quiet -n move_fail_left -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -i|--inplace)
	      inplace=1
	      shift
	      ;;

      -q|--quiet)
	      quiet=1
	      shift
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
	      usage 1
	      ;;

      *)  csv=$1
	      shift
	      ;;

    esac
  done

  if [[ -n $csv ]]; then
    if [[ ! -f $csv ]]; then
      echo -e "\e[1;31m-E-\e[0m No such file: \e[1m$file\e[0m"
      usage 1
    fi

    csv=$(readlink -e $csv)
  else
    csv=/dev/stdin
  fi

  cd $SUB_DIR

  cp $csv file.bak

  fail_idx=$(grep '^status' file.bak | sed 's/,/\n/g' | nl -nln | grep FAIL | cut -f1 | xargs | sed 's/ /,/g')
  pass_idx=$(grep '^status' file.bak | sed 's/,/\n/g' | nl -nln | grep PASS | cut -f1 | xargs | sed 's/ /,/g')

  has_sep=$(grep -c '^sep=' file.bak)

  sed -i '/sep=/d' file.bak
  paste -d, <(cut file.bak -d, -f1) <(cut file.bak -d, -f$fail_idx) <(cut file.bak -d, -f$pass_idx)  | if ((has_sep)); then
    sed '1i sep=,'
  else
    cat
  fi | if ((inplace)); then
    cat > $csv
  elif ((!quiet)); then
    cat
  fi
}

# Function: merge_csv
#
function _merge_csv
{
  function usage
  {
    echo "Usage: merge_csv [options] <csv> <csv>..."
    echo
    echo "Options:"
    echo "  -h, --help		  Show this help message and exit"
    echo "  -c, --count  <cnt>    Maximum number of csv tables to merge horizontally, defaults to 1"
    echo "  -x, --xpad   <pad>	  Horizontal padding, defaults to 1"
    echo "  -y, --ypad   <pad>	  Vertical padding, defaults to 2"
    echo "  -t, --tpad   <pad>	  Top padding, defaults to 0"
    echo "  -l, --lpad   <pad>	  Left padding, defaults to 0"
    echo "  -o, --output <file>	  Output CSV file, defaults to merge_<yyyy><mm><dd>_<hh><mm><ss>.csv"
    echo "  -s, --separator	  Add a separator to the output"
    echo
    echo "Arguments:"
    echo "  <csv>...		  CSV files to process. In addition they may be provided from stdin"
    echo
    exit ${1:-0}
  }

  if ((!$#)); then
    usage 1
  fi

  opt=$(getopt -a -oh,c:,x:,y:,t:,l:,o:,s -lcount:,xpad:,ypad:,tpad:,lpad:,output:,separator -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -c|--count)
	      count=$2
	      shift 2
	      ;;

      -x|--xpad)
	      xpad=$2
	      shift 2
	      ;;

      -y|--ypad)
	      ypad=$2
	      shift 2
	      ;;

      -t|--tpad)
	      tpad=$2
	      shift 2
	      ;;

      -l|--lpad)
	      lpad=$2
	      shift 2
	      ;;

      -o|--output)
	      output=$2
	      shift 2
	      ;;

      -s|--separator)
	      separator=1
	      shift
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
	        usage 1
	        ;;

      *)  csv[$((csvid++))]=$1
	        shift
	        ;;

    esac
  done

  tmp_csv=(${csv[@]})
  csv=()
  if [[ -p /dev/stdin ]]; then
    tmp_csv+=($(cat))
  fi

  for f in "${tmp_csv[@]}"; do
    if [[ ! -f $f ]]; then
      echo -e "\e[1;31m-W-\e[0m No such file: \e[1m$f\e[0m"
      continue
    fi

    csv+=($(readlink -e $f))
  done

  if ((${#csv[@]} < 2)); then
    echo -e "\e[1;31m-E-\e[0m At least 2 csv files are required"
    usage 1
  fi

  if ((count)); then
    if ((count > ${#csv[@]})); then
      count=${#csv[@]}
    fi
  fi

  if [[ -z $output ]]; then
    output=$(readlink -f merge_$(date +%Y%m%d_%H%M%S).csv)
  else
    output=$(readlink -f $output)
  fi

  count=${count:-1}
  xpad=$(if [[ -z $xpad ]]; then echo 2; elif (( $xpad <= 0)); then echo 1; else echo $((xpad+1)); fi)
  ypad=$(if [[ -z $ypad ]]; then echo 2; elif (( $ypad <= 0)); then echo 0; else echo $ypad; fi)
  lpad=$(if [[ -z $lpad ]]; then echo 0; elif (( $lpad <= 0)); then echo 0; else echo $lpad; fi)
  tpad=$(if [[ -z $tpad ]]; then echo 0; elif (( $tpad <= 0)); then echo 0; else echo $tpad; fi)

  xpad_str=$(yes , | head -$xpad | xargs | sed -r 's/\s+//g')
  lpad_str=$(yes , | head -$lpad | xargs | sed -r 's/\s+//g')

  cd $SUB_DIR

  k=0
  for f in "${csv[@]}"; do
    cp $f ${k}__$(basename $f)

    ((k++))
  done
  
  csv=($(ls -1tr +([[:digit:]])__*.csv))

  #echo "${csv[@]}"

  m=0
  while ((${#csv[@]})); do
    #echo "count=$count files: ${csv[@]:0:$count}"
    maxlines=$(wc -l "${csv[@]:0:$count}" | head -$count | sed -r 's/^\s+//' | cut -d' ' -f1 | sort -run | head -1)
    #echo 1 maxlines=$maxlines

    #echo "files< ${csv[@]:0:$count} >"

    for f in "${csv[@]:0:$count}"; do
      num_comma=($(head -1 $f | grep -o , | wc -l))
      line2append=$(seq $num_comma | xargs | sed -r 's/\s*\S+/,/g')
      lc=$(wc -l $f | cut -d' ' -f1)
      num_line2append=$((maxlines - lc))

      #echo num_comma=$num_comma line2append=$line2append lc=$lc num_line2append=$num_line2append f=$f

      # seq $num_line2append | sed -r 's/.*/'"$line2append"'/g' >> $f
      yes $line2append | head -$num_line2append >> $f
    done

    #echo 2 maxlines=$maxlines
    yes "$xpad_str" | head -$maxlines > xpad.csv
    yes "$lpad_str" | head -$maxlines > lpad.csv

    eval "paste  ${lpad:+lpad.csv} $(sed "s/ / xpad.csv /g" <<< "${csv[@]:0:$count}")" | sed 's/\t//g' > merge$m.csv

    #ls merge$m.csv
    # Remove empty lines or lines consisting only of empty cells
    # sed -ri '/^,+$/d' merge$m.csv


    csv=(${csv[@]:$count})

    ((m++))
  done

  # Determine the maximum number of columns
  maxcol=$(cat merge*.csv | xargs -ILINE bash -c 'echo "LINE" | grep -o , | wc -l' | sort -run | head -1)
  maxcol_str=$(yes , | head -$maxcol | xargs | sed -r 's/\s+//g')

  yes $maxcol_str | head -$ypad > ypad.csv
  yes $maxcol_str | head -$tpad > tpad.csv

  # Make sure all merge*.csv have the same number of columns
  # For that go through each of them and add empty columns if necessary
  # Empty in CSV terms means adding enough commas (,) to fill the columns to maxcol
  for f in merge*.csv; do
    cp $f tmp.csv

    cat tmp.csv | while read line; do
      num_comma=$(echo $line | grep -o , | wc -l)
      if ((num_comma < maxcol)); then
        echo $line | sed -r "s/.*/&$(yes , | head -$((maxcol-num_comma)) | xargs | sed -r 's/\s+//g')/"
      else
        echo $line
      fi
    done > $f
  done
  
  eval "cat tpad.csv $(echo merge*.csv | sed "s/ / ypad.csv /g")" > $output

  if ((separator)); then
    simenv csv_separator add $output
  fi
}

# Function: offset_csv
#
function _offset_csv
{
  function usage
  {
    echo "Usage: offset_csv [options] <csv> <csv>..."
    echo
    echo "Options:"
    echo "  -h, --help			  Show this help message and exit"
    echo "  -t, -y, --tpad, -ypad <pad>	  Top offset or Y offset,  defaults to 0"
    echo "  -l, -x, --lpad, -xpad <pad>	  Left offset or X offset, defaults to 0"
    echo "  -s, --separator		  Add a separator to the output"
    echo
    echo "Arguments:"
    echo "  <csv>...			  CSV files to process. In addition they may be provided from stdin"
    echo
    exit ${1:-0}
  }

  if ((!$#)); then
    usage 1
  fi

  opt=$(getopt -a -oh,x:,y:,t:,l:,o:,s -lxpad:,ypad:,tpad:,lpad:,output:,separator -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -x|--xpad|-l|--lpad)
	      lpad=$2
	      shift 2
	      ;;

      -y|--ypad|-t|--tpad)
	      tpad=$2
	      shift 2
	      ;;

      -s|--separator)
	      separator=1
	      shift
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
	      usage 1
	      ;;

      *)  csv[$((csvid++))]=$1
	        shift
	        ;;

    esac
  done

  tmp_csv=(${csv[@]})
  csv=()
  if [[ -p /dev/stdin ]]; then
    tmp_csv+=($(cat))
  fi

  for f in "${tmp_csv[@]}"; do
    if [[ ! -f $f ]]; then
      echo -e "\e[1;31m-W-\e[0m No such file: \e[1m$f\e[0m"
      continue
    fi

    csv+=($(readlink -e $f))
  done

  if ((${#csv[@]} < 2)); then
    echo -e "\e[1;31m-E-\e[0m At least 2 csv files are required"
    usage 1
  fi

  lpad=$(if [[ -z $lpad ]]; then echo 0; elif (( $lpad <= 0)); then echo 0; else echo $lpad; fi)
  tpad=$(if [[ -z $tpad ]]; then echo 0; elif (( $tpad <= 0)); then echo 0; else echo $tpad; fi)

  lpad_str=$(yes , | head -$lpad | xargs | sed -r 's/\s+//g')

  cd $SOURCE_DIR

  yes $'\n' | head -$tpad > tpad.csv

  for f in "${csv[@]}"; do
    lc=$(wc -l $f | cut -d' ' -f1)

    yes "$lpad_str" | head -$lc > lpad.csv
    paste  ${lpad:+lpad.csv} $f > left.csv

    yes $'\n' | head -$tpad > top.csv
    cat top.csv left.csv > ${f/csv/offset.csv}

    if ((separator)); then
      simenv csv_separator add ${f/csv/offset.csv}
    fi
  done

}

# Function: csv_2xls
#
function _csv_2xls
{
  function usage
  {
    echo "Usage: csv_2xls [options] [<csv>...]"
    echo
    echo "Options:"
    echo "  -h, --help      show this help message and exit"
    echo "  -q, --quiet     suppress output"
    echo "  -d, --dir       output directory, defaults to current directory"
    echo "  -m, --merge     merge multiple csv files into one xlsx file, one per sheet"  
    echo
    echo "  -o, --output  <xlsx>"
    echo "                  output file name, defaults to merge_yyyymmdd_hhmmss.xlsx"
    echo
    echo "Arguments:"
    echo "  <csv>...	    CSV files to process. In addition they may be provided from stdin"

    exit ${1:-0}
  }

  opt=$(getopt -a -oh,q,d:,m,o: -l help,quiet,dir:,merge,output: -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -q|--quiet)
	      quiet=1
	      shift
	      ;;

      -d|--dir)
        dir=$(readlink -e $2)
        if [[ -z $dir ]]; then
          echo -e "\e[1;31m-E-\e[0m No such directory: \e[1m$2\e[0m"
          usage 2
        fi

	      shift 2
	      ;;

      -m|--merge)
        merge=1
        shift
        ;;

      -o|--output)
        output=$(readlink -f $2)
        if [[ -z $output ]]; then
          echo -e "\e[1;31m-E-\e[0m No such directory: \e[1m$(dirname $2)\e[0m"
          usage 2
        fi

        shift 2
        ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
	      usage 2
	      ;;

      *)  csv[$((csvid++))]=$1
	        shift
	        ;;
    esac
  done

  if [[ -p /dev/stdin ]]; then
    csv+=($(cat))
  fi

  # Making sure all csv files actually exist
  for f in "${csv[@]}"; do
    if [[ ! -f $f ]]; then
      echo -e "\e[1;31m-E-\e[0m No such file: \e[1m$f\e[0m"
      continue
    fi

    exist[$((existid++))]=$(readlink -e $f)
  done

  csv=(${exist[@]})

  if [[ -n $dir ]]; then
    if [[ ! -d $dir ]]; then
      echo -e "\e[1;31m-E-\e[0m No such directory: \e[1m$dir\e[0m"
      usage 1
    fi

    cd $dir
  fi


  if ((${#csv[@]} > 1 && merge)); then
    defauflt_output=merge_$(date +"%Y%m%d_%H%M%S").fods
    if [[ -n $output ]]; then
      defauflt_output=$(echo $output | cut -d. -f1).fods
    fi

    unoconv -f fods ${csv[@]}
    sed -n '/<office:spreadsheet>/ {:end; n; /<\/office:spreadsheet>/b; b end}; p' ${csv[0]/.csv/.fods} > $defauflt_output
    sed -n '/<office:spreadsheet>/ {h; :end; n; H; /<\/office:spreadsheet>/ {g; p; z; b}; b end}' ${csv[@]//.csv/.fods} > sheets.xml
    sed -i '/<office:body>/r sheets.xml' $defauflt_output
    soffice --headless --convert-to xlsx:"Calc MS Excel 2007 XML" $defauflt_output

    rm sheets.xml *.fods
  else
    soffice --headless  --convert-to xlsx:"Calc MS Excel 2007 XML"  --infilter=CSV:44,34,UTF8,true  ${csv[@]}
  fi
}

# Function: status
#
function _status
{
  function usage
  {
    echo "Usage: status [options]"
    echo
    echo "Options:"
    echo "  -h, --help        show this help message and exit"
    echo "  -q, --quiet       suppress output"
    echo "  -a, --absolute    show absolute paths"
    echo

    exit ${1:-0}
  }

  opt=$(getopt -a -oh,q,a -lhelp,quiet,absolute -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      -q|--quiet)
	      quiet=1
	      shift
	      ;;

      -a|--absolute)
	      absolute=1
	      shift
	      ;;

      --) shift
	      ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
	      usage 2
	      ;;

      *)  shift
	        ;;
    esac
  done

  cd $PROJ_DIR
  echo -e "\e[1mFiles\e[0m"
  echo
  eval icmp4 status "${absolute:+$PWD/... |& grep -v 'clifden_v1_7t/\.\.\.'}"
  echo
  echo
  echo -e "\e[1mChangelists\e[0m\n"
  simenv changelist rtl verif
  echo
}

#
#
function _rerun
{
  function usage
  {
    echo "Usage: rerun [options] <log>"
    echo
    echo "Options:"
    echo "  -h, --help     show this help message and exit"
    echo
    echo "Arguments:"
    echo "  <log>          Log file to process"

    exit ${1:-0}
  }

  if ((!$#)); then
    usage 1
  fi

  opt=$(getopt -a -oh -lhelp -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
	      ;;

      --) shift
	        ;;

      -*) echo -e "\e[1;31mUnknown option: $1\e[0m"
	        usage 2
	        ;;

      *)  log=$1
	        shift
	        ;;
    esac
  done


  if [[ -n $log ]]; then
    if [[ ! -f $log ]]; then
      echo -e "\e[1;31m-E-\e[0m No such file: \e[1m$log\e[0m"
      usage 1
    fi

    log=$(readlink -e $log)
  else
    echo -e "\e[1;31m-E-\e[0m No log file provided"
    usage 1
  fi



  testname=$(simenv testname $log)
  seed=$(simenv testseed $log)
  crflog=$(simenv testcrfdir -a $log)/crf.log
  overwrite=$(grep crf $crflog | head -1 | grep -Po "'.+-overwrite \K.+(?=')")

  crf -wf $CRF_WF -tc $PROJ_INI -testcase $testname -seed $seed -count 1 -overwrite "$overwrite	DUMP_FSDB=yes UVM_VERBOSITY=MEDIUM"
}

# Function: jira
#
function _jira
{
  function usage
  {
    echo "Usage: jira [options] <jira> <file>"
    echo
    echo "Options:"
    echo "  -h, --help    show this help message and exit"
    echo "  -q, --quiet   suppress output"
    echo
    echo "Arguments:"
    echo "  <jira>: JIRA number"
    echo "  <file>: Path to either the fsdb or run.log"
    exit ${1:-0}
  }

  if ((!$#)); then
    usage 1
  fi

  local jira=${1^^}
  local file=$(readlink -e $2)

  nobackup=/everest/wwg_nobkup/workspaces/clifden_verif

  if [[ ! $jira =~ ^(CFV|ERD) ]]; then
    echo -e "\e[1;31m-E-\e[0m JIRA should start with either CFV or ERD"
    usage 1
  fi

  if [[ -z $file ]]; then
    echo -e "\e[1;31m-E-\e[0m Non existent path: \e[1m$2\e[0m"
    usage 1
  elif [[ ! -f $file ]]; then
    echo -e "\e[1;31m-E-\e[0m No such file: \e[1m$file\e[0m"
    usage 1
  fi


  rundir=$(dirname $file)
  log=$rundir/run.log
  testname=$(simenv testname $log)
  seed=$(simenv testseed $log)
  fsdb=$rundir/$testname.fsdb
  crflog=$(simenv testcrfdir -a $log)/crf.log
  overwrite=$(grep crf $crflog | head -1 | grep -Po "'.+-overwrite \K.+(?=')" | sed -r 's/ (\S+=)/\n\1/g' | simenv uniquify | paste -s -d' ')


  cd $nobackup
  if [[ ! -d $jira ]]; then
    mkdir -p $jira
  fi

  cd  $jira

  # The subdirectory name shall be like
  # yyyymmdd_HHMMSS
  jira_date=$(date +%Y%m%d_%H%M%S)
  mkdir -p $jira_date
  cd $jira_date
  
  cp  $fsdb  $log  $crflog  .

  if [[ $(ls $rundir/*.dbg 2>/dev/null) ]]; then
    mkdir -p dbg
    mv $rundir/*.dbg dbg
    has_dbg=1
  fi

  echo
  echo -e "=> \e[1m$testname\e[0m"
  echo
  echo "Failure signature:"
  echo
  echo
  echo "RTL CL#: $(simenv changelist rtl | cut -f2)"
  echo "Verif CL#: $(simenv changelist verif | cut -f2)"
  echo "Path to $(if ((has_dbg)); then echo "waves, logs and dbgs"; else echo "waves and logs"; fi):
	    $nobackup/$jira/$jira_date"
  echo
  echo "Command to load waves:
	    verdi -ssf $testname.fsdb &"
  echo
  echo "Command to reproduce:
	    crf -wf \$CRF_WF -tc \$CLIFDEN_BIN/clifden_rgr_cfg.ini -testcase $testname -seed $seed -count 1 -overwrite '$overwrite'"
  echo
}


# Function: phase_ordered_samples
#
function _phase_ordered_samples
{
  if [[ $# -ne 1 ]]; then
    echo "Usage: phase_ordered_samples <file>"
    exit 1
  fi

  local file=$(readlink -e $1)
  local basename=$(basename $file)
  local pi=$(bc -l <<< "scale=10; 4*a(1)")
  local fun=$(cut -d_ -f3 <<<$basename | sed -r 's/Hz//; s/M/*10^6/; s/G/*10^9/' | bc)
  local fs=$(echo $file | xargs dirname | xargs basename | sed -r 's/.*quad.*/4*10^9/; s/.*dual.*/8*10^9/' | bc)
  local N=$(wc -l $file | cut -d' ' -f1)

  local phase_incr=$(bc <<< "scale=10; 2*$pi*$fun/$fs")

  echo fun=$fun
  echo fs=$fs
  echo N=$N
  echo phase_increment=$phase_incr

  local phases=$(seq 0 $((N-1)) | sed -r 's%.*%echo "scale=10; phase = & * '$phase_incr'; twopi = 2*'$pi'; if (phase > twopi) {print \\"M \\", phase/twopi} else phase" | bc%e' | sed -r  '/^M / s/.*(\.\S+)/echo "scale=10; \1 * 2*'$pi'" | bc/e')

  paste <(echo "$phases") $file | sort -n -k1,1 | cut -f2 | simenv plot_samples -
}


# Function: seconds
#
function _seconds
{
  function usage
  {
    echo "Usage: seconds [options] <seconds>"
    echo
    echo "Options:"
    echo "  -h, --help	    Show this help message and exit"
    echo "  -v, --verbose   Verbose output"
    echo
    echo "Arguments:"
    echo "  <seconds>	    Number of seconds to convert"

    exit ${1:-0}
  }

  opt=$(getopt -a -oh,v -lhelp,verbose -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
          usage
          ;;

      -v|--verbose)
          verbose=1
          shift
          ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option '$1'"
          usage 1
          ;;
      
      *)  seconds=$1
          shift
          ;;
    esac
  done

  if [[ -z $seconds ]]; then
    echo -e "\e[1;31m-E-\e[0m No seconds specified"
    usage 1
  fi

  local days=$(echo  "$seconds/(24*60*60)" | bc -l | sed 's/^\./0./')
  local hours=$(echo "($days  - $(cut -d. -f1 <<<$days) ) * (24*60*60)" | bc -l  | sed 's/^\./0./' | xargs printf "%.f" | xargs -IEXP echo "EXP/(60 * 60)" | bc -l | sed 's/^\./0./')
  local mins=$(echo  "($hours - $(cut -d. -f1 <<<$hours)) * (   60*60)" | bc -l  | sed 's/^\./0./' | xargs printf "%.f" | xargs -IEXP echo "EXP/(     60)" | bc -l | sed 's/^\./0./')
  local secs=$(echo  "($mins  - $(cut -d. -f1 <<<$mins) ) * (      60)" | bc -l  | sed 's/^\./0./' | xargs printf "%.f" )

  if ((verbose)); then
    formatf='"%u : %1ud%3uh%3dm%3us\n"'
  else
    formatf='"%1ud\t%3uh\t%3dm\t%3us\n"'
  fi

   eval printf $formatf  ${verbose:+$seconds}  \
          $(cut -d. -f1 <<<$days)            \
          $(if [[ $hours =~ \.9{19} ]];  then echo $(($(cut -d. -f1 <<<$hours) + 1)); else  echo $(cut -d. -f1 <<<$hours); fi) \
          $(if [[ $mins  =~ \.9{19} ]];  then echo $(($(cut -d. -f1 <<<$mins)  + 1)); else  echo $(cut -d. -f1 <<<$mins);  fi) \
          $secs 
}


# Function: clean_crf
#
function _clean_crf
{
  if [[ -d $PROJ_RUN/CRF ]]; then
    cd $PROJ_RUN/CRF
    
    simenv file -cwd *.{html,json,txt,ini,csv,db,output,conf,csh,tcl,trd,key} REGRESSION_* novas* {lsf,tr,xlx}*.log reg_field seed SIM_* *ERROR {0..3} | xargs -L30 rm -f
    simenv dir  -cwd COMPILE verdiLog | xargs -L30 rm -rf
  fi
}

# Function: onedrive
#
function _onedrive
{
  for dir in $@; do
    cdir=$(readlink -e $dir)

    if [[ -z $(ls -A $cdir) ]]; then
      # Skip directory if empty
      continue
    fi

    if ! [[ -d $cdir ]]; then
      echo -e "\e[1;31m-E-\e[0m \e[1m$1\e[0m is not a directory or doesn't exist !"
      exit 1

    elif ! [[ $cdir =~ .+/CRF/.+ ]]; then
      echo -e "\e[1;31m-E-\e[0m Directory \e[1m$cdir\e[0m doesn't belong to CRF's hierarchy"
      exit 2
    fi

    pushd $PROJ_RUN/CRF/OneDrive 2>&1 >/dev/null

    dirbase=$(sed -r "s#$PROJ_RUN/CRF/##" <<<"$cdir" | cut -d/ -f1)

    echo -e "INFO [ONEDRIVE] Processing $PROJ_RUN/CRF/$dirbase"

    mkdir -p  $dirbase
    pushd  $dirbase 2>&1 >/dev/null

    find $cdir  -type f -not \( -name '*.fsdb' -o -name run.log \)  \
                -exec bash -c "sed -rn \"s#$PROJ_RUN/CRF/$dirbase/(.+)#mkdir -p \\\$(dirname \1); cp -up {} \\\$(dirname \1)#e\" <<<{}" \;

    popd 2>&1 >/dev/null
    popd 2>&1 >/dev/null
  done
}

# Function: replay
#
function _replay
{
  function usage
  {
    echo "Usage: replay [options] <run directory>"
    echo
    echo "Options:"
    echo "  -h, --help	      Print this help message and exit"
    echo "  -v, --verbose     Print verbose output"
    echo
    echo "  <run directory>   The run directory to replay"

    exit ${1:-0}
  }

  opt=$(getopt -a -oh,v -lhelp,verbose -- "$@")
  if [[ $? -ne 0 ]]; then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
          usage
          ;;

      -v|--verbose)
          verbose=1
          shift
          ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option '$1'"
          usage 1
          ;;

      *)  run_dir=$1
          shift
          ;;
    esac
  done


  if [[ -z $run_dir ]]; then
    echo -e "-E- No run directory provided"
    usage 1

  elif [[ ! -d $run_dir ]]; then
    echo -e "-E- Argument is not a directory"
    usage 2
  fi

  run_dir=$(readlink -e $run_dir) pwd=$PWD

  sed -rn '
    :ini
    /^ini_include_file/ {
      n
      /^\s*$/ {
        i ini_include_file=replay.ini\n
        b
      }

      b ini
    }

    s/^blocks.*/blocks = REPLAY/

    p

  ' $PROJ_INI > top.ini


  cd $SUB_DIR

  sim_fail=$(simenv file -d $run_dir SIM_FAIL) 

  if [[ $sim_fail ]]; then
    echo "$sim_fail" | xargs dirname | while read cdir; do
    testname=$(echo $cdir | xargs basename | sed -r 's/_(iter)?[[:digit:]]+$//')
      seed=$(grep -Po 'seed used:\s+\K\d+|\+ntb_random_seed=\K\d+' $cdir/run.log)

      get_test_section $testname  $seed

      echo ${testname}_$seed >> testlist
    done > sections
    
    cat <<REPLAY > tests
[ REPLAY ]
Subfamily = RFAMS_ADC

tests =  \\
$(sed '$! s/$/ \\/' testlist)


REPLAY

  cat tests sections > $pwd/replay.ini

  else
    echo -e "\e[1m-W-\e[0m No SIM_FAIL found"
  fi
}

function get_test_section
{
  _get_test_section "$@"
}

# Function: get_test_section
#
function _get_test_section
{
  function usage
  {
    echo "Usage: get_test_section <testname> <seed>"
    echo
    echo "Arguments:"
    echo "  <testname>   The test name for which the section is requested"
    echo "  <seed>       The seed to use for the test"

    exit ${1:-0}
  }

  if [[ $# -ne 2 ]]; then
    usage 1
  fi

  local testname=$1 seed=$2

  inilist=($(eval  'echo $PROJ_BIN/{'$(grep -Po 'ini_include_file\s*=\s*\K\S+' $PROJ_BIN/clifden_rgr_cfg.ini | xargs | sed 's/ /,/g')'}'))

  sed -srn '
    /^\s*\[\s*'$testname'\s*\]/ {
      s/.*/[ '${testname}_$seed' ]/
      a 'SEED=$seed'
      p
      :next
      n
      /^\s*\[/q
      s/^\s*count.+/count = 1/
      p
      $q
      b next
    }

  ' "${inilist[@]}"
}

# Function : png
#
function _png
{
  function usage
  {
    echo -e "Usage: png [--help|-h] [directory>]"
    echo
    echo "Options:"
    echo "  -h, --help	      Print this help message and exit"
    echo
    echo "Arguments:"
    echo "  <directory>   Directory to locate the png files, default is current directory"

    exit ${1:-0}
  }

  # Add an optional --directory|-d option with a default value of $PWD
  opt=$(getopt -a -oh -lhelp -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)
          usage
          ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
	        ;;

      *)  dir=$1
	        shift
          ;;

    esac
  done
  
  if [[ -n $dir ]]; then
    if [[ ! -d $dir ]]; then
      echo -e "\e[1;31m-E-\e[0m Argument is not a directory"
      usage 2
    fi

    cd $dir
  fi

  simenv file -cwd '*.png'
}

# Function: runlog
#
function _runlog
{
  function usage
  {
    echo -e "Usage: runlog [options] [<run directory>]"
    echo
    echo "Options:"
    echo "  -h, --help	      Print this help message and exit"
    echo "      --fail	      Limit to failed tests"
    echo
    echo "Arguments:"
    echo "  <run directory>   The run directory to locate log files, default is current directory"

    exit ${1:-0}
  }

  # Add an optional --directory|-d option with a default value of $PWD
  opt=$(getopt -a -oh -lhelp,fail -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      --fail)
	      fail=1
	      shift
	      ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
	        ;;

      *)  dir=$1
	        shift
	        ;;
    esac
  done
  
  if [[ -n $dir ]]; then
    if [[ ! -d $dir ]]; then
      echo -e "\e[1;31m-E-\e[0m Argument is not a directory"
      usage 2
    fi

    cd $dir
  fi

  if ((fail)); then
    sim_fail=$(simenv file -cwd SIM_FAIL)

    if [[ -n $sim_fail ]]; then
      echo "$sim_fail" | xargs dirname | xargs -L 1 -IDIR ls DIR/run.log
    else
      echo -e "\e[1m-W-\e[0m No failed testcase found"
    fi
  else
    simenv file -cwd run.log
  fi
}

# Function: log
#
# Alias to runlog
#
function _log
{
  simenv runlog "$@"
}


# Function: csv
#
function _csv
{
  function usage
  {
    echo -e "Usage: csv [options] [<run directory>]"
    echo
    echo "Options:"
    echo "  -h, --help	      Print this help message and exit"
    echo "      --fail	      Limit to failed tests"
    echo
    echo "Arguments:"
    echo "  <run directory>   The run directory to locate CSV files, default is current directory"

    exit ${1:-0}
  }

  # Add an optional --directory|-d option with a default value of $PWD
  opt=$(getopt -a -oh -lhelp,fail -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)
        usage
        ;;

      --fail)
	      fail=1
	      shift
	      ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
	        ;;

      *)  dir=$1
	        shift
	        ;;
    esac
  done
  
  if [[ -n $dir ]]; then
    if [[ ! -d $dir ]]; then
      echo -e "\e[1;31m-E-\e[0m Argument is not a directory"
      usage 2
    fi

    cd $dir
  fi

  if ((fail)); then
    sim_fail=$(simenv file -cwd SIM_FAIL)

    if [[ -n $sim_fail ]]; then
      echo "$sim_fail" | xargs dirname | xargs -L 1 -IDIR ls DIR/*.csv
    else
      echo -e "\e[1m-W-\e[0m No failed testcase found"
    fi
  else
    simenv file -cwd '*.csv'
  fi
}


# Function: csv_separator
#
function _csv_separator
{
  function usage
  {
    echo -e "Usage: csv_separator [options] add|rem [csv...]"
    echo
    echo "Options:"
    echo "  -h, --help	 Print this help message and exit"
    echo
    echo "Arguments:"
    echo "  csv...	 The csv file(s) to add/remove a separator to/from"
    echo "               May also be provided from stdin"
    
    exit ${1:-0}
  }


  opt=$(getopt -a -oh -lhelp -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      --help|-h)
	      usage
	      ;;

      --) shift
	        ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m\n"
	        usage 1
	        ;;

      *)  if ((!pos1)); then
	          pos1=1
	          subcmd=$1
	        else
	          csv[$((csvid++))]=$(readlink -e $1)
	        fi
	  
	        shift
	        ;;
    esac
  done

  if [[ -n $subcmd ]]; then
    if [[ ! $subcmd =~ ^(add|rem(ove)?|rm)$ ]]; then
      echo -e "\e[1;31m-E-\e[0m Unsupported subcommand: \e[1m$subcmd\e[0m\n"
      usage 1
    fi
  else
    echo -e "\e[1;31m-E-\e[0m No subcommand specified\n"
    usage 1
  fi

  if [[ -p /dev/stdin ]]; then
    csv=(${csv[@]} $(cat))
  fi

  if ((!${#csv[@]})); then
    echo -e "\e[1;31m-E-\e[0m No csv files specified\n"
    usage 1
  fi

  case $subcmd in
    add) sed -si '1 {
	        /^sep=/ ! i sep=,
	      }'  "${csv[@]}"
	      ;;

    remove|rem|rm)
	    sed -si '1 {/^sep=/ d}'  "${csv[@]}"
	    ;;
  esac
}


# Function: fsdb
#
function _fsdb
{
  function usage
  {
    echo -e "Usage: fsdb [options] [<run directory>]"
    echo
    echo "Options:"
    echo "  -h, --help	      Print this help message and exit"
    echo "      --fail	      Limit to failed tests"
    echo
    echo "Arguments:"
    echo "  <run directory>   The run directory to locate the run.log files, default is current directory"

    exit ${1:-0}
  }

  # Add an optional --directory|-d option with a default value of $PWD
  opt=$(getopt -a -oh -lhelp,fail -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      --fail)
	      fail=1
	      shift
	      ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
	        ;;

      *)  dir=$1
	        shift
	        ;;
    esac
  done
  
  if [[ -n $dir ]]; then
    if [[ ! -d $dir ]]; then
      echo -e "\e[1;31m-E-\e[0m Argument is not a directory"
      usage 2
    fi

    cd $dir
  fi

  if ((fail)); then
    sim_fail=$(simenv file -cwd SIM_FAIL)

    if [[ -n $sim_fail ]]; then
      echo "$sim_fail" | xargs dirname | xargs -IDIR bash -c 'ls DIR/*.fsdb 2>/dev/null'
    else
      echo -e "\e[1m-W-\e[0m No failed testcase found"
      usage 3
    fi
  else
    simenv file -cwd '*.fsdb'
  fi
}


# Function: crf_replay
#
function _crf_replay
{
  function usage
  {
    echo -e "Usage: crf_replay [options]"
    echo
    echo "Options:"
    echo "  -h, --help	      Print this help message and exit"
    echo "  -f, --fft	      Enable FFT plot generation"
    echo "  -w, --waves	      Enable waves"
    echo "  -v, --verbosity   Set verbosity level to <low|medium|high|debug>"

    exit ${1:-0}
  }

  opt=$(getopt -a -oh,f,v:,w -lhelp,verbosity:,fft,waves -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
	      usage
        ;;

      -f|--fft)
        fft=1
        shift
        ;;

      -w|--waves)
        waves=1
        shift
        ;;

      -v|--verbosity)
        verbose=$2
        shift 2
        ;;

      --) shift
        ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
    esac
  done

  crf -wf $CRF_WF -tc top.ini -block REPLAY -overwrite "TOPOLOGY=ADC${fft:+ USER_PLUSARGS=+fft_save_plot}${verbose:+ UVM_VERBOSITY=UVM_${verbose^^}}${waves:+ DUMP_FSDB=yes}"
}

# Function : crf
#
function _crf
{
  crf -wf $CRF_WF               \
      -tc $PROJ_INI             \
      -overwrite 'TOPOLOGY=ADC'
}


# Function: coverage
#
function _coverage
{
  function usage
  {
    echo -e "Usage: coverage [options] [<topology>]"
    echo
    echo -e "\e[1mOptions\e[0m"
    echo "  -h, --help        Print this help message and exit"
    echo
    echo "  -T, --topology <topology>"
    echo "                    Specify a topology to run"
    echo
    echo "  -b, --block <block>"
    echo "                    Specify a block to run, more than one block can be specified using block1,block2,..."
    echo
    echo "      --tag <tag>   Specify a test tag to run, more than one tag can be specified using tag1,tag2,..."
    echo "                    More than one --tag option can be specified"
    echo
    echo "      --testcase <test>"
    echo "                    Specify a testcase to run, more than one testcase can be specified using testcase1,testcase2,..."
    echo "                    More than one --testcase option can be specified"
    echo
    echo "  -c, --count <count>"
    echo "                    Specify a count to run"
    echo
    echo "  -n, --dry-run     Dry run. Display the command that would be run and exit"
    echo
    echo -e "\e[1mArguments\e[0m"
    echo "  <topology>        Optional positional argument to specify the topology to run. Check the -T|--topology option for an alternative."
    echo

    exit ${1:-0}
  }

  if ((!$#)); then
    usage 1
  fi

  opt=$(getopt -a -oh,b:,c:,n,T: -lhelp,block:,tag:,testcase:,count:,dry-run,topology: -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      -T|--topology)
        topology=$2
        shift 2
        ;;

      -b|--block)
        block[$((blockid++))]=$2
        shift 2
        ;;

      --tag) 
        tag[$((tagid++))]=$2
        shift 2
        ;;

      --testcase)
        testcase[$((tcid++))]=$2
        shift 2
        ;;

      -c|--count)
        count=$2
        shift 2
        ;;

      -n|--dry-run)
        dryrun=1
        shift
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
          ;;

        *)  if ((posarg_cnt)); then
              echo -e "\e[1;31m-E-\e[0m Only one positional argument supported: \e[1m$topology $1\e[0m\n"
              usage 1
            else
              topology=$1
              shift
            fi  

            ((posarg_cnt++))
            ;;
    esac
  done


  for ((i=0; i<${#block[@]}; i++)); do
    for b in $(echo ${block[$i]} | sed 's/,/ /g'); do
      blocks[$((blocksid++))]=$b
    done
  done

  if ((!${#blocks[@]})); then
    echo -e "\e[1;31m-E-\e[0m No block specified\n"
    usage 1
  elif ((${#block[@]} > 1)); then
    echo -e "\e[1;31m-E-\e[0m More than one block specified\n"
    usage 1
  fi

  for ((i=0; i<${#tag[@]}; i++)); do
    for t in $(echo ${tag[$i]} | sed 's/,/ /g'); do
      tags[$((tagsid++))]=$t
    done
  done

  for ((i=0; i<${#testcase[@]}; i++)); do
    for tc in $(echo ${testcase[$i]} | sed 's/,/ /g'); do
      testcases[$((tcsid++))]=$tc
    done
  done


  block_str=$(echo ${blocks[@]} | sed 's/ / -block /g; s/^/-block /') 
  tag_str=$(echo ${tags[@]} | sed 's/ / -tag /g')
  testcase_str=$(echo ${testcases[@]} | sed 's/ / -testcase /g; s/^/-testcase /')
  count_str="-count $count"

  cp -f $PROJ_BIN/Makefile .
  cp -f $PROJ_BIN/Makefile_clifden .
  cp -f $PROJ_DIR/scripts/gen_urg_vplan_cmd .
  
  sed -i 's%\$(CLIFDEN_BIN)/Makefile_clifden%'$PWD/Makefile_clifden% Makefile
  sed -i '
    s/\$(RGR_COUNT).*/$(RGR_COUNT)/
    /\$(RGR_DIR).log/d
    /-rundir /d
    s%\S\+gen_urg_vplan_cmd%'$PWD'/gen_urg_vplan_cmd%
  ' Makefile_clifden

  urg_cmd=$(readlink -m urg.cmd)
  vplan_cmd=$(readlink -m vplan.cmd)

  sed -ri '
    /set\sRGR_DIR/d
    s%\S+_urg.cmd%'$urg_cmd'%
    s%\S+_vplan.cmd%'$vplan_cmd'%
    s%\$\{CLIFDEN_RUN\}/\$\{RGR_DIR\}%'$PWD'%
    s%\$\{TOPOLOGY\}/%'${blocks[0]}/'%
  ' gen_urg_vplan_cmd

  make_cmd="make run_rgr  RGR_REGTAG=COV_$(date +%Y%m%d_%H%M%S) TOPOLOGY=$topology  \
                          ${block_str:+RGR_TST_GRP=\"$block_str\"}                  \
                          ${tag_str:+TAG=\"$tag_str\"}                              \
                          ${count:+RGR_COUNT=\"$count_str\"}                        \
                          ${testcase_str:+RGR_EMAIL=\"$testcase_str\"}              \
                          URG_CMD=$urg_cmd VPLAN_CMD=$vplan_cmd                     \
                          "

  if ((dryrun)); then
    echo $make_cmd
  else
    eval $make_cmd
  fi
}


# Function: samples_2xls
#
function _samples_2xls
{
  function usage {
    echo -e "\e[1mUsage:\e[0m samples_2xls [options] [<directory>...] [<log>...]"

    echo
    echo -e "\e[1mDescription:\e[0m"
    echo "  Convert datapath and calibration samples and checks to xls format"

    echo
    echo -e "\e[1mOptions:\e[0m"
    echo "  --help, -h"
    echo "        Display this help message"

    echo "  --datapath, --dp , -d"
    echo "        Generate datapath Excel file(s)"
    echo 
    echo "  --calibration, --cal, -c"
    echo "        Generate calibration Excel file(s)"
    echo
    echo "  --slice, -s <slice>"
    echo "        Generate Excel file(s) only for specified slice"
    echo "        If not specified, defaults to all slices"
    echo
    echo -e "\e[1mArguments\e[0m"
    echo "  <directory>...    Optional positional directory arguments to specify the directories to work on."
    echo "                    If not specified, and no run.log is provided either, the current directory is used."
    echo "                    May also be provided from stdin."
    
    echo
    echo "  <log>...          Optional positional log arguments to specify the log files to work on."
    echo "                    May also be provided from stdin."
    echo


    exit ${1:-0}
  }


  opt=$(getopt -a -oh,d,c,s: -lhelp,dp,datapth,cal,calibration,slice: -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  all_slices=1 dp_cal=1

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      --datapath|--dp|-d)
        dp=1
        dp_cal=0
        shift
        ;;

      --calibration|--cal|-c)
        cal=1
        dp_cal=0
        shift
        ;;

      -s|--slice)
        slice=$2
        all_slices=
        shift 2
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
          ;;

      *)  posarg[$((posargs_id++))]=$1 
          shift
          ;;

      esac
  done
   
  if [[ -p /dev/stdin ]]; then
    posarg+=($(cat))
  fi

  logs=($(for item in "${posarg[@]}"; do
    if [[ -f $item ]]; then
      if [[ $item =~ .*run.log$ ]]; then
        if [[ ! -f $item ]]; then
          echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m does not exist"
          continue
        fi

        echo $item
      else
        echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m is not a run.log" 
        continue
      fi
    else
      # Should be a directory
      if [[ ! -d $item ]]; then
        echo -e "\e[1;31m-E-\e[0m Directory or File \e[1m$item\e[0m does not exist" 1>&2
        continue
      else
        simenv log $item
      fi
    fi

  done | simenv uniquify))

  if ((!${#logs[@]})); then
    logs=($(simenv log))
  fi

  # echo all_slices=$all_slices  slice=$slice dp=$dp cal=$cal

  for log in "${logs[@]}"; do
    crundir=$(dirname $log)
    ctestdir=$(basename $crundir)

    echo "Processing $crundir"

    pushd $crundir > /dev/null

    for k in $(seq 0 3); do 
      if ((all_slices || slice == k)); then
        if ((dp_cal || dp)); then
          simenv merge_csv -c3 -x2 -o dp_$k.csv  sbs_i_model_$k.csv sbs_i_design_$k.csv sbs_i_check_$k.csv
        fi

        if ((dp_cal || cal)); then
          simenv merge_csv -c4 -x2 -o cal_$k.csv cal_dbg_model_$k.csv cal_model_$k.csv   cal_design_$k.csv   cal_check_$k.csv
        fi
      fi
    done

    if ((dp_cal || dp)); then
      simenv csv_2xls   ${all_slices:+-m -o ${ctestdir}_datapath_$(date +%Y%m%d).xlsx dp_0.csv  dp_1.csv  dp_2.csv  dp_3.csv} ${slice:+dp_$slice.csv}
    fi

    if ((dp_cal || cal)); then
      simenv csv_2xls   ${all_slices:+-m -o ${ctestdir}_calibration_$(date +%Y%m%d).xlsx cal_0.csv cal_1.csv cal_2.csv cal_3.csv} ${slice:+cal_$slice.csv}
    fi

    popd > /dev/null
  done
}

# Function: samples_count_2xls
#
function _samples_count_2xls
{
  function usage {
    echo -e "\e[1mUsage:\e[0m samples_count_2xls [options] [<directory>...] [<log>...]"

    echo
    echo -e "\e[1mDescription:\e[0m"
    echo "  Extract the number of samples pushed to CAL/DATAPATH queues to xls format"

    echo
    echo -e "\e[1mOptions:\e[0m"
    echo "  --help, -h            Display this help message"
    echo "  --output, -o <excel>  Output Excel file name, defaults to samples_count_$(date +%Y%m%d).xlsx"

    echo
    echo -e "\e[1mArguments\e[0m"
    echo "  <directory>...    Optional positional directory arguments to specify the directories to work on."
    echo "                    If not specified, and no run.log is provided either, the current directory is used."
    echo "                    May also be provided from stdin."
    
    echo
    echo "  <log>...          Optional positional log arguments to specify the log files to work on."
    echo "                    May also be provided from stdin."
    echo


    exit ${1:-0}
  }


  opt=$(getopt -a -oh,o: -lhelp,output: -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      -o|--output)
        output=$(readlink -f $2)
        if [[ -z $output ]]; then
          echo -e "\e[1;31m-E-\e[0m Path leading to output file has non-existing directory component(s)"
          usage 1
        fi

        shift 2
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
          ;;

      *)  posarg[$((posargs_id++))]=$1 
          shift
          ;;

      esac
  done
   
  if [[ -p /dev/stdin ]]; then
    posarg+=($(cat))
  fi

  logs=($(for item in "${posarg[@]}"; do
    if [[ -f $item ]]; then
      if [[ $item =~ .*run.log$ ]]; then
        if [[ ! -f $item ]]; then
          echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m does not exist"
          continue
        fi

        echo $item
      else
        echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m is not a run.log" 
        continue
      fi
    else
      # Should be a directory
      if [[ ! -d $item ]]; then
        echo -e "\e[1;31m-E-\e[0m Directory or File \e[1m$item\e[0m does not exist" 1>&2
        continue
      else
        simenv log $item
      fi
    fi

  done | simenv uniquify))

  if ((!${#logs[@]})); then
    logs=($(simenv log))
  fi

  if [[ -z $output ]]; then
    output=$PWD/samples_count_$(date +%Y%m%d).xlsx
  fi

  for log in "${logs[@]}"; do
    crundir=$(dirname $log)
    ctestdir=$(basename $crundir)

    echo "Processing $crundir" 1>&2

    pushd $crundir > /dev/null

    (
      echo Test,$(simenv testname run.log)
      iter=$(simenv testiter run.log)
      if [[ $iter ]]; then
        echo Iter,$iter
      fi
      echo Seed,$(simenv testseed run.log)
      echo Status,$(simenv teststatus run.log)
      
      for k in $(seq 0 3); do 
        for f in cal_model_$k.csv  cal_design_$k.csv cal_check_$k.csv sbs_i_model_$k.csv sbs_i_design_$k.csv sbs_check_$k.csv; do
          if [[ -f $f ]]; then
            wc -l $f | sed -r 's/^\s+//' | sed -r 's/(\S+)\s(\S+)/\2,\1/; s/\.csv//'
          else
            echo $f,0 | sed -r 's/\.csv//'
          fi | sed -r 's/_/ /g; s/cal/CAL/; s/sbs/DATAPATH/; s/model/MODEL/; s/design/DESIGN/; s/check/CHECK/; s/\<i\>/I/; s/\<q\>/Q/'
        done
      done
    ) | simenv transpose_csv 

    popd > /dev/null
  done | sed -rn '1p; 1! {/^Test/!p}' > $SUB_DIR/samples_count.csv

  simenv csv_2xls -o $output $SUB_DIR/samples_count.csv
}


# Function: log_2csv
#
function _log_2csv
{
  function usage {
    echo -e "\e[1mUsage:\e[0m log_2csv [options] [<directory>...] [<log>...]"

    echo
    echo -e "\e[1mDescription:\e[0m"
    echo "  Extract the number of samples pushed to CAL/DATAPATH queues to xls format"

    echo
    echo -e "\e[1mOptions:\e[0m"
    echo "  --help, -h        Display this help message"
    echo "  --quiet, -q       Suppress output to stdout"

    echo
    echo -e "\e[1mArguments\e[0m"
    echo "  <directory>...    Optional positional directory arguments to specify the directories to work on."
    echo "                    If not specified, and no run.log is provided either, the current directory is used."
    echo "                    May also be provided from stdin."
    
    echo
    echo "  <log>...          Optional positional log arguments to specify the log files to work on."
    echo "                    May also be provided from stdin."
    echo


    exit ${1:-0}
  }


  opt=$(getopt -a -oh,q -lhelp,quiet -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      -q|--quiet)
        quiet=1
        shift
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
          ;;

      *)  posarg[$((posargs_id++))]=$1 
          shift
          ;;

      esac
  done
   
  if [[ -p /dev/stdin ]]; then
    posarg+=($(cat))
  fi

  logs=($(for item in "${posarg[@]}"; do
    if [[ -f $item ]]; then
      if [[ $item =~ .*run.log$ ]]; then
        if [[ ! -f $item ]]; then
          echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m does not exist"
          continue
        fi

        echo $item
      else
        echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m is not a run.log" 
        continue
      fi
    else
      # Should be a directory
      if [[ ! -d $item ]]; then
        echo -e "\e[1;31m-E-\e[0m Directory or File \e[1m$item\e[0m does not exist" 1>&2
        continue
      else
        simenv log $item
      fi
    fi

  done | simenv uniquify))

  if ((!${#logs[@]})); then
    logs=($(simenv log))
  fi


  for log in "${logs[@]}"; do
    rundir=$(dirname $log)
    testdir=$(basename $rundir)

    if ((!quiet)); then
      echo "Processing $rundir" 1>&2
    fi

    pushd $rundir > /dev/null

    grep ^csv: run.log | grep :Index | cut -d: -f2 | sed 's/$/.csv/' | xargs rm -f
    grep ^csv: run.log | sed -rn 's/^csv:(\w+):(.+)/echo "\2" >> \1.csv/e'

    for k in 0 1 2 3; do
      nl -v0 rfadc_cal_model_${k}_0.dbg/opb.txt | sed -r 's/^\s+//; s/\s+/,/; 1iIndex,dbg opb Model '$k'' > cal_dbg_model_$k.csv
    done

    popd > /dev/null
  done
}


# Function: samples_status
#
function _samples_status
{
  function usage {
    echo -e "\e[1mUsage:\e[0m samples_status [options] [<directory>...] [<log>...]"

    echo
    echo -e "\e[1mDescription:\e[0m"
    echo "  Extract the status of the calibration following simulations"

    echo
    echo -e "\e[1mOptions:\e[0m"
    echo "  --help, -h            Display this help message"

    echo
    echo -e "\e[1mArguments\e[0m"
    echo "  <directory>...    Optional positional directory arguments to specify the directories to work on."
    echo "                    If not specified, and no run.log is provided either, the current directory is used."
    echo "                    May also be provided from stdin."
    
    echo
    echo "  <log>...          Optional positional log arguments to specify the log files to work on."
    echo "                    May also be provided from stdin."
    echo


    exit ${1:-0}
  }


  opt=$(getopt -a -oh,o: -lhelp,output: -- "$@")
  if (($?)); then
    usage 1
  fi

  eval set -- $opt

  while (($#)); do
    case $1 in
      -h|--help)
        usage
        ;;

      --) shift
          ;;

      -*) echo -e "\e[1;31m-E-\e[0m Unknown option \e[1m$1\e[0m"
          usage 1
          ;;

      *)  posarg[$((posargs_id++))]=$1 
          shift
          ;;

      esac
  done
   
  if [[ -p /dev/stdin ]]; then
    posarg+=($(cat))
  fi

  logs=($(for item in "${posarg[@]}"; do
    if [[ -f $item ]]; then
      if [[ $item =~ .*run.log$ ]]; then
        if [[ ! -f $item ]]; then
          echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m does not exist"
          continue
        fi

        echo $item
      else
        echo -e "\e[1;31m-E-\e[0m File \e[1m$item\e[0m is not a run.log" 
        continue
      fi
    else
      # Should be a directory
      if [[ ! -d $item ]]; then
        echo -e "\e[1;31m-E-\e[0m Directory or File \e[1m$item\e[0m does not exist" 1>&2
        continue
      else
        simenv log $item
      fi
    fi

  done | simenv uniquify))

  if ((!${#logs[@]})); then
    logs=($(simenv log))
  fi

  START_DIR=$PWD
  CSV_DIR=$START_DIR/_csv
  mkdir -p $CSV_DIR
  rm -f $CSV_DIR/*


  for log in "${logs[@]}"; do
    rundir=$(dirname $log)
    testdir=$(basename $rundir)
    prefix=$(echo $testdir | sed -r 's/adc_quad_|test_iter|_test\>//g')

    echo "Processing $rundir" 1>&2

    pushd $rundir > /dev/null

    simenv log_2csv -q

    #
    # OPB
    #
    rm -f opb.csv
    (
      echo "slice,0,1,2,3"
      for t in model design check; do
        for s in 0 1 2 3; do
          if [[ -f cal_${t}_$s.csv ]]; then
            lc=$(wc -l cal_${t}_$s.csv | sed -rn 's/([[:digit:]]+).+/\1/p')
            
            if ((lc)); then
              echo $((lc - 1))
            else
              echo X
            fi
          else
            echo X
          fi
        done | xargs echo $t | sed 's/ /,/g'
      done

      # I DIFF
      for s in 0 1 2 3; do
        if [[ -f cal_check_$s.csv ]]; then
          diffc=$(tail -n +2 cal_check_$s.csv | grep ERROR | wc -l)
          echo $diffc
        else
          echo X
        fi
      done | xargs echo diff count | sed 's/ /,/2g'

      # I SAME
      for s in 0 1 2 3; do
        if [[ -f cal_check_$s.csv ]]; then
          samec=$(tail -n +2 cal_check_$s.csv | grep -v ERROR | wc -l)
          echo $samec
        else
          echo X
        fi
      done | xargs echo same count | sed 's/ /,/2g'

      # I DISCARDED MODEL AND DESIGN
      for t in model design; do
        for s in 0 1 2 3; do
          if [[ -f cal_${t}_$s.csv ]]; then
            discarded=$(tail -n +2 cal_${t}_$s.csv | grep X$ | wc -l) 
            echo $((discarded))
          else
            echo X
          fi
        done | xargs echo $t discarded | sed 's/ /,/2g'
      done
    ) | sed -r '/slice|count/! s/^/opb /' | simenv transpose_csv | sed -r 's/([^,]+,[^,]+,[^,]+),([^,]+,[^,]+,[^,]+),([^,]+),([^,]+)/\1,\3,\4,\2/' > opb_tmp.csv 


    #
    # RA TL
    #
    rm -f ra_tl.csv
    (
      (
        echo "slice,subadc"
        for s in 0 1 2 3; do
          for subadc in 0 1; do
            echo $s,$subadc
          done
        done
      ) | simenv transpose_csv

      for t in model design; do
        for p in ra; do
          for s in 0 1 2 3; do
            for subadc in 0 1; do
              if [[ -f ${t}_${p}_tl_ad__${s}_${subadc}.csv ]]; then
                lc=$(wc -l ${t}_${p}_tl_ad__${s}_${subadc}.csv | sed -rn 's/([[:digit:]]+).+/\1/p')

                if ((lc)); then
                  echo $((lc - 1))
                else
                  echo X
                fi
              else
                echo X
              fi
            done
          done | xargs echo $p tl $t | sed 's/ /,/3g'
        done
      done

      # DIFF data (#4) and addr (#5)
      for t in data addr; do
        for s in 0 1 2 3; do
          for subadc in 0 1; do
            if [[ $t == data ]]; then
              off=4
            else
              off=5
            fi

            if [[ -f model_ra_tl_ad__${s}_${subadc}.csv && -f design_ra_tl_ad__${s}_${subadc}.csv ]]; then
              diffc=$(paste <(cut -d, -f$off model_ra_tl_ad__${s}_${subadc}.csv  | tail -n +2)   \
                            <(cut -d, -f$off design_ra_tl_ad__${s}_${subadc}.csv | tail -n +2) | \
                            sed -rn 's/^(\S+)\s(\S+)/echo $((\1 != \2))/ep' | grep '^1' | wc -l)

              echo $diffc
            else
              echo X
            fi
          done
        done | xargs echo $t diff count | sed 's/ /,/3g'
      done
    )  | simenv transpose_csv > ra_tl.csv

    #
    # SHARED TL
    #
    rm -f shared_tl.csv
    (
      (
        echo "slice,subadc"
        for s in 0 1 2 3; do
          for subadc in 0 1; do
            echo $s,$subadc
          done
        done
      ) | simenv transpose_csv

      # WORD COUNT
      for t in model design; do
        for p in shared; do
          for s in 0 1 2 3; do
            for subadc in 0 1; do
              if [[ -f ${t}_${p}_tl_ad__${s}_${subadc}.csv ]]; then
                lc=$(wc -l ${t}_${p}_tl_ad__${s}_${subadc}.csv | sed -rn 's/([[:digit:]]+).+/\1/p')

                if ((lc)); then
                  echo $((lc - 1))
                else
                  echo X
                fi
              else
                echo X
              fi
            done
          done | xargs echo $p tl $t | sed 's/ /,/3g'
        done
      done

      # DIFF data (#4) and addr (#5)
      for t in data addr; do
        for s in 0 1 2 3; do
          for subadc in 0 1; do
            if [[ $t == data ]]; then
              off=4
            else
              off=5
            fi

            if [[ -f model_shared_tl_ad__${s}_${subadc}.csv && -f design_shared_tl_ad__${s}_${subadc}.csv ]]; then
              diffc=$(paste <(cut -d, -f$off model_shared_tl_ad__${s}_${subadc}.csv  | tail -n +2)   \
                            <(cut -d, -f$off design_shared_tl_ad__${s}_${subadc}.csv | tail -n +2) | \
                            sed -rn 's/^(\S+)\s(\S+)/echo $((\1 != \2))/ep' | grep '^1' | wc -l)

              echo $diffc
            else
              echo X
            fi
          done
        done | xargs echo $t diff count | sed 's/ /,/3g'
      done
    )  | simenv transpose_csv > shared_tl.csv

    #
    # DATA
    #
    rm -f data.csv
    (
      echo "slice,0,1,2,3"
      for t in model design check; do
        for s in 0 1 2 3; do
          if [[ -f sbs_i_${t}_$s.csv ]]; then
            lc=$(wc -l sbs_i_${t}_$s.csv | sed -rn 's/([[:digit:]]+).+/\1/p')
            
            if ((lc)); then
              echo $((lc - 1))
            else
              echo X
            fi
          else
            echo X
          fi
        done | xargs echo $t | sed 's/ /,/g'
      done

      # I DIFF
      for s in 0 1 2 3; do
        if [[ -f sbs_i_check_$s.csv  ]]; then
          diffc=$(tail -n +2 sbs_i_check_$s.csv | grep ERROR | wc -l)
          echo $diffc
        else
          echo X
        fi
      done | xargs echo diff count | sed 's/ /,/2g'

      # I SAME
      for s in 0 1 2 3; do
        if [[ -f sbs_i_check_$s.csv ]]; then
          samec=$(tail -n +2 sbs_i_check_$s.csv | grep -v ERROR | wc -l)
          echo $samec
        else
          echo X
        fi
      done | xargs echo same count | sed 's/ /,/2g'

      # I DISCARDED MODEL AND DESIGN
      for t in model design; do
        for s in 0 1 2 3; do
          if [[ -f sbs_i_${t}_$s.csv ]]; then
            discarded=$(tail -n +2 sbs_i_${t}_$s.csv | grep X$ | wc -l) 
            echo $((discarded))
          else
            echo X
          fi
        done | xargs echo $t discarded | sed 's/ /,/2g'
      done

    ) | sed -r '/slice|count/! s/^/data /' | simenv transpose_csv | sed -r 's/([^,]+,[^,]+,[^,]+),([^,]+,[^,]+,[^,]+),([^,]+),([^,]+)/\1,\3,\4,\2/' > data.csv 



    simenv merge_csv -o samples_status.csv opb.csv ra_tl.csv shared_tl.csv data.csv
    mv samples_status.csv $CSV_DIR/$prefix.csv

    popd > /dev/null
  done

  pushd $CSV_DIR > /dev/null

  if (($(ls *.csv | wc -l))); then
    simenv csv_2xls -m -o samples_status_$(date +%Y%m%d_%H%M%S).xlsx $(ls -tr *.csv)
  else
    simenv csv_2xls *.csv
  fi

  mv *.xlsx ..
  cd ..
  rm -rf $CSV_DIR

  popd > /dev/null
}
